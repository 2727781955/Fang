---
date: 2025-04-12
author: Fang
---
# 线索二叉树的概念
我们知道，在使用二叉链表作为二叉树的存储结构时，可以很方便地找到某个结点地左右孩子结点；但是一般情况下，我们无法找到该结点在某种遍历序列中的前驱和后继结点

*那我们该怎么找到特定序列下某个结点的前驱和后继呢？*
- 将二叉树按照遍历顺序重新遍历寻找，但是较为浪费时间；
- 再增设前驱和后继指针域，但是增加了空间负担；
- **利用二叉链表中的空指针域**：将空的左孩子结点指针改为指向其前驱；空的右孩子结点指针改为指向其后继
>在前面我们说过，对于一个有`n`个结点的二叉链表，其中就有`n+1`个指针域为空

这种**改变了指向的指针**称为**线索**，而加上了线索的二叉树我们就称为**线索二叉树**，对二叉树按照某种遍历次序使其变为线索二叉树的过程叫做**线索化**


# 线索二叉树的存储结构
- 在二叉链表中，每个结点有两个指针域：`Lchild` 和 `Rchild`；
- 在不影响树结构的前提下，将**原本指向空的左右指针**用于存储该节点在某种遍历顺序下的**前驱或后继节点地址**，这种指针称为“线索”；
- 对应地，节点会增加两个**线索标志位**，用于区分当前指针是“子树”还是“线索”：
    - `Ltag == 0` 表示 `Lchild` 是左孩子；
    - `Ltag == 1` 表示 `Lchild` 是前驱线索；
    - `Rtag == 0` 表示 `Rchild` 是右孩子；
    - `Rtag == 1` 表示 `Rchild` 是后继线索
线索化后的结点结构：

| `Lchild` | `Ltag` | `data` | `Rtag` | `Rchild` |
| -------- | ------ | ------ | ------ | -------- |
在这里我们看到，与之前相比，在结点中新增了两个`int`值；`int`类型的值，每个占位4字节；
虽然也有额外的内存开销，但是我们让空指针也承担实际作用，**不需要新开辟空间**来存储前驱/后继指针；
在处理的是海量结点的树结构时，哪怕节省几个字节，也会带来明显效果
## 代码实现
```C
// 定义线索二叉树节点结构
typedef struct BiThrNode {
    char data;
    struct BiThrNode *Lchild, *Rchild;
    // Ltag==0表示Lchild是左孩子，1表示线索；Rtag同理
    int Ltag, Rtag;
} BiThrNode, *BiThrTree;
```
# 线索化二叉树
对于二叉链表，三种不同的遍历方式，就能遍历出三种不同的序列；在这里我们讨论在**中序遍历**下，将普通二叉树的线索化
## 算法思想
- 遍历顺序：左子树 → 当前节点 → 右子树
- 若当前节点的左孩子为空，将其 `Lchild` 指向中序前驱节点；
- 若前驱节点的右孩子为空，将其 `Rchild` 指向当前节点（即后继）；
- 用一个 `pre` 指针始终记录当前节点的前驱；
- 对于叶子节点，一侧指针指向前驱、一侧指针指向根节点；增强树的循环结构，方便遍历
## 代码实现
```C
BiThrNode *pre = NULL;
void InThreading(BiThrNode *T, BiThrNode *root) {
    if (T) {
        InThreading(T->Lchild, root);
        if (!T->Lchild) {
            T->Ltag = 1;
            T->Lchild = pre ? pre : root; // 若没有前驱，指向根节点
        }
        if (pre && !pre->Rchild) {
            pre->Rtag = 1;
            pre->Rchild = T;
        }
        // 如果当前是叶子节点，则将空指针指向根节点
        if (!T->Lchild && !T->Rchild) {
            if (T->Ltag == 0) {
                T->Ltag = 1;
                T->Lchild = root;
            }
            if (T->Rtag == 0) {
                T->Rtag = 1;
                T->Rchild = root;
            }
        }
        pre = T;
        InThreading(T->Rchild, root);
    }
}
```