---
time: 2025-06-12
author: Fang
tags:
  - 选择排序
  - 堆排序
  - 简单排序
---
# 学习目标
- [ ] 
- [ ]    

选择排序是一种简单直观的排序算法，属于交换排序的一种特殊形式
它的核心思想是：每一趟从未排序的序列中选出最小（或最大）元素，放到已排序序列的末尾，直到所有元素排序完成
# 一、算法思想概述
- 将序列分为已排序区和未排序区，初始时已排序区为空，未排序区为整个序列
- 每次从未排序区中找到最小（或最大）元素
- 将该最小元素与未排序区的第一个元素交换位置
- 已排序区长度加一，未排序区长度减一
- 重复以上步骤，直到未排序区为空，序列排序完成


- 选择排序主要有两种：
	- **简单选择排序**：每趟直接在未排序区找到最小（或最大）元素，与未排序区首元素交换
	- **堆排序**：利用堆这种特殊的树形结构，高效选出最大（或最小）元素，优化了选择过程，提高排序效率

下面来分别介绍

# 二、简单选择排序
## 1.算法思想
简单选择排序的核心就是**不断选择最小元素放到序列前端**，每趟**只交换一次**，减少了交换次数，但比较次数依然较多
- 主要步骤如下：
	- 在待排序序列中，**每一趟从未排序的元素中选择最小（或最大）元素**
	- 将该元素与未排序区的第一个元素交换位置
	- 这样经过第一趟后，最小元素被放到序列起始位置，已排序区长度加一，未排序区长度减一
	- 重复以上过程，直到所有元素都被排序完毕
## 2.代码实现
```C
void selectionSort(int arr[], int n) {
    int i, j, minIndex, temp;
    for (i = 0; i < n - 1; i++) {
        minIndex = i; // 假设当前i为最小元素位置
        for (j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j; // 找到更小元素，更新minIndex
            }
        }
        // 交换当前i位置和minIndex位置的元素
        if (minIndex != i) {
            temp = arr[i];
            arr[i] = arr[minIndex];
            arr[minIndex] = temp;
        }
    }
}
```
## 3.举例
假设待排序数组为：64, 25, 12, 22, 11，求选择排序后的序列

*排序步骤如下*：
- 第1趟：找最小元素11，和第一个元素64交换，数组变为：11, 25, 12, 22, 64
- 第2趟：找剩余元素中最小的12，和第二个元素25交换，数组变为：11, 12, 25, 22, 64
- 第3趟：找剩余元素中最小的22，和第三个元素25交换，数组变为：11, 12, 22, 25, 64
- 第4趟：找剩余元素中最小的25，已在正确位置，无需交换
- 排序完成，最终数组为：11, 12, 22, 25, 64
## 4.性能分析
- 无论排序的序列顺序如何，所需要的**比较次数都相同**，均为$\sum_{i=1}^{n-1}(n-i)=\frac{n(n-1)}{2}$
- 交换次数：
	- 最好情况：不需要交换，次数为0
	- 最坏情况：每一次都需要交换，次数为$n-1$，赋值次数为$3(n-1)$
所以：
- 时间复杂度为$O(n^2)$
- 空间复杂度为$O(1)$

简单选择排序**不是稳定排序算法**
# 三、堆排序
## 1.堆的定义
堆（Heap）是一种特殊的树形数据结构，满足以下两个核心特性：

- **完全二叉树结构**：堆通常表现为一棵完全二叉树，即除最后一层外，每层节点都达到最大数目，最后一层节点集中在左侧

- **堆序性质**：堆中任意节点的值都满足特定的大小关系：
    - **大根堆**：每个节点的值都大于或等于其所有子节点的值，堆顶元素是整个堆中的最大值
    - **小根堆**：每个节点的值都小于或等于其所有子节点的值，堆顶元素是整个堆中的最小值

如有以下两个序列：{98 77 35 62 55 14 35 48}、{14 48 35 62 55 98 35 77}

*我们可以得到如下的树结构*：
![[Pasted image 20250612220109.png]]
我们利用堆结构的特性，就能迅速找到最大（最小的元素），剩下的元素又能重新建成一个堆结构，这样重复n次，就能得到一个有序序列，这个过程我们称之为**堆排序**

实现堆排序需要解决两个问题：
1. 如何由一个无序序列建成一个堆？
2. 如何在输出堆顶元素后，调整剩余元素为一个新的堆？

### 无序序列建堆
以大根堆为例：
- **从最后一个非叶子节点开始**（下标为n/2-1，数组下标从0开始），依次向前对每个节点执行下沉调整
    - 比较该节点与其左右子节点的值，找出最大值所在节点
    - 若最大值不是当前节点，交换两者，然后继续对被交换的子节点递归执行下沉
- 最后完成所有非叶子节点的调整后，整个序列即构成大根堆
### 剩余元素建堆（下浮调整算法）
以大根堆为例：
- 将堆顶元素（最大值）与堆尾元素交换，移除堆尾元素（即最大值已排序）
- 对新的堆顶元素执行下沉调整
    - 比较该节点与其左右子节点，找出最大值节点
    - 若最大值不是当前节点，交换并继续向下调整，直到堆性质恢复
### 举例
我们有序列{10, 2, 11, 8, 7}，求其构建大根堆的过程和去除根元素后堆结构的重建过程

*构建大根堆*

待排序序列：{10, 2, 11, 8, 7}
将其看成完全二叉树（数组下标从0开始）：
```
          10(0)
         /     \
      2(1)     11(2)
     /    \
   8(3)   7(4)
```

**步骤1：找到最后一个非叶子节点**  
节点索引为(n-2)/2 = (5-2)/2 = 1，即节点2（索引1）

**步骤2：从最后一个非叶子节点开始向前调整堆**

- 调整节点2（值为2）：
    - 左子节点8（索引3），右子节点7（索引4）
    - 最大子节点为8，8 > 2，交换2和8
    - 交换后子树变为：节点8（索引1），节点2（索引3）
    - 继续对节点2（索引3）下沉，节点2为叶子，无需继续调整

序列变为：{10, 8, 11, 2, 7}

- 调整节点0（值为10）：
    - 左子节点8（索引1），右子节点11（索引2）
    - 最大子节点为11，11 > 10，交换10和11
    - 交换后子树变为：节点11（索引0），节点10（索引2）
    - 继续对节点10（索引2）下沉，节点10无子节点，无需继续调整
        
序列变为：{11, 8, 10, 2, 7}

此时整个序列满足大根堆性质


*输出堆顶元素后调整堆*

输出堆顶元素11，将堆尾元素7放到堆顶：
    
序列变为：{7, 8, 10, 2, 11}（将11放末尾，不参与后续堆调整）

- 对堆顶7执行下沉调整：
    - 左子节点8，右子节点10，最大子节点为10
    - 10 > 7，交换7和10 
    - 继续对节点7（索引2）下沉，节点7无子节点，调整结束
        
序列变为：{10, 8, 7, 2, 11}

### 代码实现
```C
//下浮调整函数
void heapify(int arr[], int n, int i) {
    int largest = i;          // 初始化最大值为当前节点
    int left = 2 * i + 1;     // 左子节点索引
    int right = 2 * i + 2;    // 右子节点索引

    if (left < n && arr[left] > arr[largest]) {
        largest = left;
    }
    if (right < n && arr[right] > arr[largest]) {
        largest = right;
    }
    if (largest != i) {
        // 交换父节点和最大子节点
        int temp = arr[i];
        arr[i] = arr[largest];
        arr[largest] = temp;

        // 递归调整被交换的子节点
        heapify(arr, n, largest);
    }
}

//无序建堆使用整理函数来实现
void buildMaxHeap(int arr[], int n) {
    // 从最后一个非叶子节点开始，向前调整每个节点
    for (int i = (n - 2) / 2; i >= 0; i--) {
        heapify(arr, n, i);
    }
}
```
## 2.算法思想
- **建堆**：从最后一个非叶子节点开始（索引为 $⌊\frac{n−2}2⌋$），依次向前对每个节点执行“下沉调整”（heapify算法），使其子树满足大顶堆性质

- **堆排序**：
    - 逐步输出堆顶元素，并将堆顶元素与堆尾元素交换，堆大小减1
    - 对新的堆顶元素执行“下沉调整”，恢复堆结构
    - 重复上述过程直到堆大小为1
## 3.代码实现
```C
void heapSort(int arr[], int n) {
    buildMaxHeap(arr, n);  // 构建大根堆

    for (int i = n - 1; i > 0; i--) {
        swap(&arr[0], &arr[i]);  // 将堆顶最大元素放到末尾
        heapify(arr, i, 0);      // 调整剩余元素为大根堆
    }
}
```
## 4.性能分析
- 时间复杂度：
    - 建堆时间复杂度为 O(n)
    - 每次调整堆时间复杂度为$O(log⁡_2n)$，共进行$n−1$次调整
    - 整体时间复杂度为$O(log⁡_2n)$
        
- 空间复杂度：原地排序，空间复杂度为O(1)
    
- 稳定性：堆排序是不稳定的排序算法