---
time: 2025-05-29
author: Fang
---
# 学习目标
- [ ] 理解图的生成树定义及其基本性质
- [ ] 掌握图生成树的构造思路 


“生成树”作为图的一个核心概念，广泛应用于网络连接、路径规划和最小代价设计等场景；本节我们来梳理**图的生成树的性质与构造方法**
# 一、什么是图的生成树？
前面我们介绍过图的最小生成树，即——对于一个**无向连通图** $G=(V,E)$，其生成树**是包含图中所有顶点的一个极小连通子图**

如下所示的图结构：
![[Pasted image 20250529171412.png|250]]
则它的几个生成树结构为：
![[Pasted image 20250529172910.png|650]]
- 一个图可以具有多个不同的生成树
- 所有生成树具有以下特性：
	- 生成树顶点个数与图的顶点个数相同
	- 生成树是图的极小连通子图，去掉任意一条边就非连通；加上任意一条边就必然形成回路
	- 一个有n个顶点的连通图的生成树有n-1条边
	- 生成树中任意两个顶点间的路径是唯一的

下面我们学习图生成树的构造
# 二、图生成树的构造算法
## 1.算法思路
- 设图 G=(V,E)是个连通图，当从图任一顶点出发遍历图G 时，将边集 E(G)分成两个集合T(G)和B(G)
- 其中，T(G)是遍历图时所经过的边的集合，B(G)是遍历图时未经过的边的集合
- 显然，G1(V,T)是图 G的极小连通子图，即子图G1是连通图G的生成树
- 根**据遍历方法（深度遍历和广度遍历）的不同，也就会构造出不同的生成树**
## 2.示例
有这样的一个无向图结构：
![[Pasted image 20250529130904.png|300]]
根据遍历方式的不同，我们能得到不同的最小生成树，如下图：
![[Pasted image 20250529181128.png|600]]

## 3.代码实现
我们以邻接表+DFS算法为例：
```C
void DFS_GenTree(ALGraph G, int v) {
    visited[v] = true;
    ArcNode *p = G.vertices[v].firstarc;    //从指定起始顶点开始遍历
    while (p != NULL) {
        int w = p->adjvex;                            //w是v的第一个邻接点
        if (!visited[w]) {
            // 输出生成树的边 (v, w)
            cout << "(" << G.vertices[v].data << "," << G.vertices[w].data << ")" << endl;
            DFS_GenTree(G, w); // 继续向下递归
        }//if
        p = p->nextarc;             //移动到下一个顶点
    }//while
}//DFS_GenTree
```