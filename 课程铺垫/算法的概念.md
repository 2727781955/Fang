---
date: 2025-03-01
author: Fang
---
# 算法的描述
- 自然语言
- 流程图：传统流程图，NS流程图
- 伪代码：类C语言
# 算法的定义
对特定问题求解方法和步骤的一种描述，它是指令的有限序列，其中每个指令表示一个或者多个操作
简而言之，**算法就是解决问题的方法和步骤**

## 算法与程序
- 算法是解决问题的一种或者一个过程，考虑如何将输入转换成输出，一个问题可以由多种算法
- 程序是某种程序设计语言对算法的具体实现
					**程序 = 数据结构 + 算法**
# 算法的特性
一个算法必须具备以下五个特性:
1. 有穷性：每一个算法必须在有穷步的有穷时间内完成
2. 确定性：每一条指令必须有确切的含义，只有唯一的执行路径
3. 可行性：算法是可执行的
4. 输入：一个算法有零个或者多个输入
5. 输出：一个算法有一个或者多个输出
# 算法的设计
- 正确性
- 可读性
- 健壮性
- 高效性
#  算法的优劣的衡量

一个好的算法首先要具备正确性，然后是健壮性，可读性，在几个方面都满足的情况下，主要考虑算法的效率，通过算法的效率高低来评判不同算法的优劣程度
算法效率主要以下面两个方面来考虑：
1. 时间效率：指的是算法所消耗的时间
2. 空间效率：指的是算法执行过程中所耗费的储存空间
**时间效率和空间效率有时候是矛盾的**

# 算法效率的度量
## 算法时间效率的度量
可以用依据该算法编制的程序在计算机上执行所消耗的时间来度量
两种度量方式
- 事后统计
- 事前分析  分析公式：**∑**语句频度  * 每条语句执行时间

为了便于比较不同算法的时间效率，我们仅比较它们的数量级
称作算法的渐进时间复杂度O(f(n))，简称**时间复杂度**
如果有 f(n) 的多次项 则**时间复杂度取最高次项**
![[Pasted image 20250301194827.png]]

如上图，求时间复杂度，只需要找出嵌套最深层的语句，求出对应语句的频度

### 时间复杂度的计算
-  例一：
```C
void exam(float x[][],int m,int n){
	float sun[];
	for(int i = 0;i < m; i++){  //执行了m次
		sum[i] = 0.0;
		for(int j = 0;j< n;j++){ //执行了n次
			sum[i] += x[i][j]; //嵌套最深的语句，执行了m*n次
		}
	}
	for(i = 0;i<n;i++){
		cout<<i<<":"<<sum[i]<<endl;
	}
}
//得O(f(n)) = m*n
```
-  例二
```C
for(int i = 1;i <= n;i++){ //执行n次
	for(int j = 1;j <= i;j++){ //执行i次
		for(int k = 1;k <= j;K++){ //执行j次
			x += 1; //嵌套最深的语句
		}
	}
}
```
则得语句频度$\sum_{\mathrm{i=1}}^{\mathrm{n}}\sum_{\mathrm{j=1}}^{\mathrm{i}}\left(\sum_{\mathrm{k=1}}^{\mathrm{j}}1\right)$ = $\sum_{\mathrm{i=1}}^{\mathrm{n}}\sum_{\mathrm{j=1}}^{\mathrm{i}}\mathrm{j}$  

经计算，最高次为三次方，则得时间复杂度为O(f(n)) = $n^3$


- 例三
```C
for(int i = 0;i<n;i++){
	if(a[i] ==e) return i+1; //找到，则返回是第几个元素
	return 0;
}
```
最好的情况：一次找到
最坏的情况：n次找到
平均时间复杂度：O（n）

在计算时间复杂度的时候，一般总是考虑最坏情况下的时间复杂度，以保证算法运行时的时间不会比它更长

### 算法时间效率的比较
当n取得很大时，指数时间算法和多项式时间算法在所需时间上非常悬殊

![[Pasted image 20250302135749.png]]
时间复杂度阶数越高，时间复杂度越大，在选择算法时，要尽量选择阶数低的算法

## 算法空间效率的度量

- 空间复杂度：算法所需要的存储空间的度量，记作：S(n) = O(f(n))，其中n为问题的规模(大小)

- 算法要占据的空间：
	1. 算法本身要占据的空间，输入输出，指令我，常数，变量等
	2. 算法要使用的辅助空间 

### 算法空间复杂度的计算
```C
//算法一
for(int i = 0;i<n;i++){
	int t = 0;
	t = a[i];
	a[i] = a[n-i-1];
	a[n-i-1] = t; //其中t就是辅助空间
}

//算法二
for(int i = 0;i<n;i++){
	b[i] = a[n-i-1];
}
for(i = 0;i<n;i++){
	a[i] = b[i];
}
```
- 算法一原地工作，空间复杂度:S(n) = O(1)；
- 算法二借用一维数组，空间复杂度：S(n) = O(n)
则算法一的空间效率高

# 小结
## 如何设计一个好的算法

抽象数据类型 = 数据的逻辑结构 + 抽象运算（运算的功能描述）

数据的逻辑结构 `->` 数据的存储结构n1,n2,n3........ `->` 算法m1,m2,m3........ 

设计一个好的程序，就是对算法进行设计分析，一个好的算法，就是要计算算法的空间复杂度和时间复杂度，从中进行衡量