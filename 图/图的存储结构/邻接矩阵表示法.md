---
time: 2025-05-11
author: Fang
tags:
  - 邻接矩阵
  - 图结构
  - 无向图
  - 有向图
  - 网图
---
# 学习目标
- [ ] 
- [ ]    

我们知道，在图结构中，每个顶点之间的关系没有固定形式，所以也就不能使用传统的线性结构、链式结构来直接表示，所以我们引入了**邻接矩阵表示法**和**多重链表表示法**
本节我们来介绍邻接矩阵表示法
# 一、无向图邻接矩阵表示法
## 1.实现思路
- 建立一个*顶点表*（记录各个顶点信息），和一个*邻接矩阵*（表示各个顶点之间的关系）
	- 设图`A=(V,E)`有n个顶点，则有顶点表`Vex[n]`，记录每个顶点
	- 图的邻接矩阵是一个二维数组`A.arcs[n][n]`，定义为
$$A.arcs[i][j] =
\begin{cases}
1, & \text{如果 } \langle i, j \rangle \in E \text{ 或者 } (i, j) \in E \\
0, & \text{否则}
\end{cases}$$
- 临接矩阵式表示了顶点之间的关系，如果两个顶点之间存在边，则数组表示为1，否则表示为0

## 2.举例
我们有下面这样的一个图结构：
![[Pasted image 20250524203506.png|300]]
- 我们则能根据顶点之间的关系，创建出邻接矩阵$A.arcs[n][n]$
![[Pasted image 20250524202140.png|350]]
## 3.无向图邻接矩阵的规律
- 对于无向图的邻接矩阵，有如下规律：
	- 对角线元素均为零（因为没有顶点与自己有边关系）
	- 无向图的邻接矩阵是对称的（顶点之间的边关系是相对的）
	- 通过每一行（每一列）“1”的数量，我们就能确定每一个顶点的度
	- 对于一个完全图，对角线元素为0，其余全部为1
# 二、有向图的邻接矩阵表示法
## 1.实现思路
有向图邻接矩阵的建立思路与无向图相同，不同的是在填入0或1时考虑顶点之间边关系的方向
- 在一个有向图的邻接矩阵中：
	- 第$V_i$行记录了以结点$V_i$为起点的边
	- 第$V_i$列记录了以结点$V_i$为终点的边
## 2.举例
有这样的一个有向图：
![[Pasted image 20250524205324.png|350]]
- 则根据规则，我们能创建如下的邻接矩阵
![[Pasted image 20250524204453.png|375]]
## 3.有向图邻接矩阵的规律
- 对于无向图的邻接矩阵，有如下规律：
	- 对角线元素均为零（因为没有顶点与自己有边关系）
	- 矩阵可能不是对称的（边关系是有向的）
	- 通过每一行的“1”的数量，我们能确认顶点$V_i$的出度；通过每一列的“1”的数量，我们能确认顶点$V_i$的入度；*出度和入度之和就是顶点的度*
# 三、网（有权图）的邻接矩阵表示法
## 1.实现思路
与有向图类似，但是对于矩阵中填入的数据，我们填入的就不是0或1了，而是边所带有的**权值**
- 邻接矩阵$A.arcs[i][j]$的定义：
$$A.arcs[i][j] =
\begin{cases}
W_{ij}, & \text{如果 } \langle i, j \rangle \in E \text{ 或者 } (i, j) \in E \\
 ∞, & \text{否则}
\end{cases}$$
- 这里我们使用无限（ ∞）来表示两个顶点之间没有边关系，方便后面的算法进行运算
## 2.举例
有这样的一个网结构：
 ![[Pasted image 20250524210722.png|500]]
 我们根据定义能获得它的邻接矩阵：
 ![[Pasted image 20250524210755.png|450]]
# 四、图(网)邻接矩阵的代码实现
## 1.存储结构的实现
- 我们使用**两个数组**来分别存储顶点表和邻接矩阵
```C
#define MaxInt 10000         //表示极大值,用于网结构中权值的赋值
#define MVNum 100;           //设置最大顶点数
typedef char VerTexType;  //设顶点的数据类型为字符型
typedef int ArcType;          //假设变得权值类型为整形

typedef struct {
	VerTexType vexs[MVNum];  //顶点表
	ArcType arcs[MVNum][MVNum]; //邻接矩阵
	int vexnum,arcnum;             //图的当前点数和边数
}AMGraph 
```
- 这就是图的邻接矩阵初始化后的结构，对于不同形式的网结构（有向、无向；带权、不带权）分别进行特别的处理，将网中的数据填入
- 接下来介绍无向网的邻接矩阵的建立
## 2.无向网的邻接矩阵的建立
### 算法思想
- 先确定总顶点数和总边数
- 依次输入点的信息存入顶点表中
- 初始化邻接矩阵，使每个权值初始化为极大值
- 根据权值来构造邻接矩阵
### 代码实现
```C
Status CreateUDN(AMGraph &G){
	cin>>G.vexnum>>G.arcnum;      //输入总顶点数和总边数
	for(i = 0;i<G.vexnum;++i){       //依次出入顶点的信息
		cin>>G.vex[i];
	}
	for(i = 0;i<G.vexnum;++i){
		for(j = 0;j<G.vexnum;++j){
			G.arcs[i][j] = MaxInt;    //初始化矩阵，将边关系的值设置为无限大
		}
	}
	for(k = 0;k<G.vexnum;++k){
		cin>>v1>>v2>>w;                  //输入一条边所依附的顶点以及其权值
		i = LoacteVex(G,v1);         
		j = LocateVex(G,v2);        //确定v1、v2在G中的位置
		G.arcs[i][j] = w;                //将权值重置为w
		G.arcs[j][i] = G.arcs[i][j]; //无向网两顶点之间的权值相等
	}
	return OK;
}
```
- 在这里函数`LocateVex`是图的顶点查找算法，根据顶点的值来查找顶点的位置，具体实现如下：
```C
int LocateVex(AmGraph G,VertexType u){
	int i;
	for(i = 0;i<G.vexnum;++i){
		if(u == G.vex[i]) return i;       //若顶点值相同，返回位置
	}
	return -1;                                  //否则，返回-1
}
```

## 3.其他图结构的实现
- 无向图，就是不带有权值的网结构；在初始化时，我们将每一个权值初始为0，在构造邻接矩阵时，如果两个顶点之间有边关系，我们再将权值重置为1
- 有向图，它的邻接矩阵是非对称矩阵，我们仅为`G.arcs[i][j] `赋值，不用给`G.arcs[j][i] `赋值
- 有向图，结合了上面两个结构的特点，初始时权值为0，也只需要给边关系赋值为1一次
# 五、邻接矩阵的优缺点
## 1.优点
- 直观、简单、好理解
- 方便检查任意一对顶点之间是否存在边
- 方便找任一顶点的所有邻接点
- 方便计算任一顶点的度（从该顶点发出的边数为出度，指向该顶点的边数为入度）
	- 无向图：对应行（或列）非零元素的个数
	- 有向图：对应行非零元素的个数是出度，对应列非零元素的个数是入度，顶点的度为二者相加
如图，对下面这个邻接矩阵，我们可以得出以下信息：
$$\left[\begin{array}{c c c c c}{{0}}&{{1}}&{{0}}&{{1}}&{{0}}\\ {{1}}&{{0}}&{{1}}&{{0}}&{{1}}\\ {{0}}&{{1}}&{{0}}&{{1}}&{{1}}\\ {{1}}&{{0}}&{{1}}&{{0}}&{{0}}\\ {{0}}&{{1}}&{{1}}&{{0}}&{{0}}\end{array}\right]$$
- 这是一个无向图，有五个顶点
- 每个顶点之间的连接关系
- 每个顶点的度

得到如下的无向图：
![[Pasted image 20250528154324.png|325]]
## 2.缺点
- 如果要对图的元素进行增删，就要更改矩阵的结构，十分不便
- 存在稀疏图时（顶点很多，但是边很少），有大量无效元素，浪费空间
- 统计图中的边数时，要遍历完矩阵中所有的元素，浪费大量时间
