---
time: 2025-05-30
author: Fang
tags:
  - 图论
  - 最短路径算法
  - Dijkstra算法
  - Floyd算法
  - 有向带权图
---
# 学习目标
- [ ] 理解最短路径问题及其图论建模方式
- [ ] 掌握 Dijkstra 与 Floyd 两种最短路径算法的核心原理与应用场景
- [ ] 能够结合示例手动推导并实现最短路径算法

在日常生活中，我们驾车或者出行时，都会有交通路线选择的问题——甲地到乙地有多条路径，选择哪一条路最短？
于是我们引出了最短路径的概念，通过将路线问题抽象为**有向带权图**，我们就能借助图算法来系统地解决路径选择难题

# 一、常见最短路径问题
我们能把现实路径问题抽象成以下数学模型：
- 交通网络使用有向图来表示；
- 地点使用顶点表示；
- 两个地点之间的路线用弧表示；
- 两地之间的距离、花费、所需时间用弧上的权值表示
  
最短路径主要有两类问题：
## 第一类：两点之间最短路径
*有如下的网结构：*
![[Pasted image 20250603203731.png|550]] 
*求从v1到v7的路径及路径长度：*

| 路径                 | 路径长度   |
| ------------------ | ------ |
| v1、v2、v5、v7        | 20     |
| **v1、v4、v2、v5、v7** | **14** |
| v1、v2、v7           | 23     |
| v1、v4、v2、v7        | 17     |
| v1、v4、v6、v7        | 26     |
*由上表我们可知：*
v1、v4、v2、v5、v7是最短路径，为14

## 第二类：从某点到其他各点的最短路径
*有如下的网结构：*
![[Pasted image 20250605183122.png|425]]
从v0点到其他各点的最短路径为：

| v0到各顶点最短路径         | 路径长度 |
| ------------------ | ---- |
| 到v1：v0-v1          | 13   |
| 到v2：v0-v2          | 8    |
| 到v3：v0-v2-v3       | 13   |
| 到v4：v0-v2-v3-v4    | 19   |
| 到v5：v0-v2-v3-v4-v5 | 21   |
| 到v6：v0-v1-v6       | 20   |
## 最短路径算法
- 从单一源点到所有其他顶点的最短路径的问题（单源问题），采用**Dijkstra**算法
- 求所有顶点间的最短路径的问题，采用**Floyd**算法

下面来介绍这两种算法

# 二、Dijistra算法
Dijkstra算法通过**贪心策略**逐步扩展最短路径，最终求出从源点 $v_0$ 到所有顶点的最短路径
## 1.算法思路
- 初始化两个集合：
    - $S$：已确定最短路径的顶点集合，初始为 ${v_0}$； 
    - $T$：待确定的顶点集合，为其余所有顶点 
- 使用数组 $D[i]$ 记录当前从 $v_0$ 到 $v_i$ 的最短路径长度。初值为：
    - 若 $<v_0, v_i>$ 存在，则为其权值； 
    - 否则为 ∞
- 每次从 $T$ 中选取使 $D[i]$ 最小的顶点 $v_j$ 加入 $S$；
- 用 $v_j$ 作为中间点，更新其他未确定点的最短距离；
- 重复直到所有顶点加入 $S$，即全部路径确定
## 2.举例
*有如下的网结构，求从V0到其他各顶点的最短路径：*
![[Pasted image 20250605183122.png|425]]
*算法步骤如下*：
1. 初始时，辅助数组$D$：

|  终点  | 从 v₀ 到各终点的最短路径及长度 |     |     |     |     |     |
| :--: | :---------------: | :-: | :-: | :-: | :-: | :-: |
| 执行次数 |        i=1        | i=2 | i=3 | i=4 | i=5 | i=6 |
|  v₁  |        13         |     |     |     |     |     |
|  v₂  |         8         |     |     |     |     |     |
|  v₃  |         ∞         |     |     |     |     |     |
|  v₄  |        30         |     |     |     |     |     |
|  v₅  |         ∞         |     |     |     |     |     |
|  v₆  |        32         |     |     |     |     |     |
|  vⱼ  |        v₂         |     |     |     |     |     |
| 最短距离 |         8         |     |     |     |     |     |
这时，我们看到距离最短的顶点为V2，我们将V2加入S集合，将V2作为中间结点来更新最短路径

2. 执行第二次后的最短路径更新为：

|  终点  | 从 v₀ 到各终点的最短路径及长度 |     |     |     |     |     |
| :--: | :---------------: | :-: | :-: | :-: | :-: | :-: |
| 执行次数 |        i=1        | i=2 | i=3 | i=4 | i=5 | i=6 |
|  v₁  |        13         | 13  |     |     |     |     |
|  v₂  |         8         |  \  |     |     |     |     |
|  v₃  |         ∞         | 13  |     |     |     |     |
|  v₄  |        30         | 30  |     |     |     |     |
|  v₅  |         ∞         |  ∞  |     |     |     |     |
|  v₆  |        32         | 32  |     |     |     |     |
|  vⱼ  |        v₂         | v₁  |     |     |     |     |
|  距离  |         8         | 13  |     |     |     |     |
重复上面的操作，将V3加入S集合，并将V3作为中间节点继续更新最短路径

3. 重复执行几次后，直到所有顶点都加入S集合后，我们得到如下表格，即单源顶点的最短路径表：

|  终点  | 从 v₀ 到各终点的最短路径及长度 |     |     |     |     |     |
| :--: | :---------------: | :-: | :-: | :-: | :-: | :-: |
| 执行次数 |        i=1        | i=2 | i=3 | i=4 | i=5 | i=6 |
|  v₁  |        13         | 13  |  \  |  \  |  \  |  \  |
|  v₂  |         8         |  \  |  \  |  \  |  \  |  \  |
|  v₃  |         ∞         | 13  | 13  |  \  |  \  |  \  |
|  v₄  |        30         | 30  | 30  | 19  |  \  |  \  |
|  v₅  |         ∞         |  ∞  | 22  | 22  | 21  | 21  |
|  v₆  |        32         | 32  | 20  | 20  | 20  |  \  |
|  vⱼ  |        v₂         | v₁  | v₃  | v₄  | v₆  | v₅  |
|  距离  |         8         | 13  | 13  | 19  | 20  | 21  |
# 三、Floyd算法
- 对于一个有向图，我们可以**重复执行n次Dijkstra算法**，来遍历获得所有顶点间的最短路径，但是较为繁琐
- 我们可以采用**Floyd**算法，来更简便地求出所有顶点间的最短距离
## 1.算法思路
1. 初始时，我们设置一个n阶方阵，令其对角线元素为0，若存在弧$<V_i,V_j>$，则对应元素为其权值；否则为无穷大（∞）
2. 接着逐步在原有的直接路径上增加中间顶点，若加入中间顶点后路径变短，则修改路径长度，否则维持原值；所有顶点试探完毕后，算法结束
## 2.举例
*有如下的图结构，求每个点到其余各点的最短路径*：
![[Pasted image 20250607164503.png|450]]
*算法步骤如下*：
1. 初始的路径矩阵为：

| **AA** | **AB** | **AC** |
| ------ | ------ | ------ |
| **BA** | **BB** | **BC** |
| **CA** | **CB** | **CC** |
其值为：
$$\begin{bmatrix}{0}&{4}&{11}\\{6}&{0}&{2}\\{3}&{\infty}&{0}\end{bmatrix}$$
2. 我们尝试将中间节点加入之前的原路径，如果存在更小的路径，就将路径矩阵中的值进行替换

如：
- 加入A顶点后，路径矩阵为

| **AA** | **AB**  | **AC** |
| ------ | ------- | ------ |
| **BA** | **BB**  | **BC** |
| **CA** | **CAB** | **CC** |
其值为：
$$\begin{bmatrix}{0}&{4}&{11}\\{6}&{0}&{2}\\{3}&{\infty→7}&{0}\end{bmatrix}$$

- 加入B顶点后，路径矩阵为：

| **AA** | **AB**  | **ABC** |
| ------ | ------- | ------- |
| **BA** | **BB**  | **BC**  |
| **CA** | **CAB** | **CC**  |
其值为：
$$\begin{bmatrix}{0}&{4}&{11→6}\\{6}&{0}&{2}\\{3}&{7}&{0}\end{bmatrix}$$


- 加入C顶点后，路径矩阵为：

| **AA**  | **AB**  | **ABC** |
| ------- | ------- | ------- |
| **BCA** | **BB**  | **BC**  |
| **CA**  | **CAB** | **CC**  |
其值为：
$$\begin{bmatrix}{0}&{4}&{6}\\{6→5}&{0}&{2}\\{3}&{7}&{0}\end{bmatrix}$$

3. 所有顶点都试探性加入后，算法结束，得到最终的最短路径矩阵
$$\begin{bmatrix}{0}&{4}&{6}\\{5}&{0}&{2}\\{3}&{7}&{0}\end{bmatrix}$$
