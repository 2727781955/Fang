---
time: 2025-04-21
author: Fang
tags:
  - 哈夫曼编码
  - 数据压缩
  - 前缀编码
  - 哈夫曼树
---
# 学习目标
- [ ] 理解哈夫曼编码的原理及其在数据压缩中的应用
- [ ] 掌握哈夫曼树的构造过程及如何生成字符编码   
- [ ] 能够实现哈夫曼编码的解码过程，并根据编码恢复原始信息 

# 哈夫曼编码的构造
## 问题描述
在远程通讯中，要将待传字符串转换成二进制的字符
比如：A——00；B——01；C——10；D——11
ABACCDA——*00*01*00*10*10*11*00*
但是并不是所有的字符串使用频率都一样，我们可以用**短的编码表示高频字符**，**长的编码表示低频字符**，从而**减少整体编码长度**
转换后：A——0；B——00；C——1；D——01
ABACCDA——*0*00*0*1*1*01*0*
显著减少了码数，但是有一个问题：在编码中出现了重码：*0000*
对于*0000*，有三种理解：AAAA、ABA、BB

为了避免这种情况，我们就要规定：**任一字符的编码都不是其他字符的编码的前缀**，这种编码叫做前缀编码，总长最短前缀编码也就是哈夫曼编码
*那怎么求得哈夫曼编码呢*
## 算法思想
1. 统计字符集中每个字符在电文中出现的平均概率，概率越大，编码越短
2. 利用哈夫曼树的特点：权越大的叶子结点离根越近；将每个字符的概率作为权值，构造哈夫曼树
3. 在哈夫曼树的每个分支上表0或者1：结点的左分支标0；右分支标1
4. 把从根结点的每个叶子结点的路径上的标号连接起来，就能作为该叶子结点代表的字符的编码
## 算法演示
现有字符集`D={C,A,S,T,M}`，及其出现出现频率`W={2,4,2,3,3}`
现在求出各字符的哈夫曼编码
解决步骤：
1. 按照哈夫曼算法，我们根据权重构造哈夫曼树，如下图：
![[Pasted image 20250421212041.png|L|500]]
2. 按照左右分支，我们在分支上标记0和1
![[Pasted image 20250421211947.png|L|500]]
3. 按照分支上的数字，我们得出每个字符的编码：
	T——00；M——01；A——10；C——110；S——111
## 算法思考
1. *为什么哈夫曼编码能够保证是前缀编码？*
	前缀编码的定义：**任一字符的编码都不是其他字符的编码的前缀**；在哈夫曼树中，没有一个叶子结点是另一个叶子结点的祖先，所以每个叶子结点的编码也就不可能是其他叶子结点编码的前缀
2. *为什么哈夫曼编码能够保证字符编码总长最短？*	
	我们设计哈夫曼树的依据，就是`WPL`最小；表现在前缀编码中，就是字符编码的总长，即$\sum编码使用频率*编码长度$最小
## 算法步骤：
在算法的实际实现中，为了效率的高效，我们采用从叶子结点依次向上遍历的方法；
- 使用一个临时数组`cd`存储哈夫曼编码，因为我们从树结构的底层出发，所以编码数组也从末尾逆序存储
- 对于每个叶子结点，从它开始向上遍历：
	- 如果当前结点是其父结点的左孩子，`cd`数组末尾存储`0`；
	- 如果是右孩子，则存储`1`；
	- 更新当前结点，继续向上遍历，直到根结点
- 将临时数组`cd`中的编码正序存储在保存所有叶子结点的编码数组`HC`中
## 代码实现
- 首先对哈夫曼树的结点结构进行定义
```C
typedef struct {
	int weight;  //结点的权重
	int parent,lchild,rchild; //孩子、双亲结点的信息
}HTNode,*Huffman Tree;
```
- 构造哈夫曼树
```C
//选择函数
void Select(HuffmanTree HT, int n, int *s1, int *s2) {
    int min1 = 0, min2 = 0;
    *s1 = *s2 = 0;
    for (int i = 1; i <= n; i++) {
        if (HT[i].parent == 0) {
            if (HT[i].weight < min1) {
                min2 = min1; 
                *s2 = *s1;
                min1 = HT[i].weight; 
                *s1 = i;   
            } else if (HT[i].weight < min2) {
                min2 = HT[i].weight;
                *s2 = i;
            }
        }
    }
//构造函数
void CreateHuffmanTree(HuffmanTree HT, int w[], int n) {
    int m = 2 * n - 1;
    for (int i = 1; i <= n; ++i) {
        HT[i].weight = w[i - 1]; 
        HT[i].parent = HT[i].lchild = HT[i].rchild = 0;
    }
    for (int i = n + 1; i <= m; ++i) {
        HT[i].weight = HT[i].parent = HT[i].lchild = HT[i].rchild = 0;
    }

    for (int i = n + 1; i <= m; ++i) {
        int s1, s2;
        Select(HT, i - 1, &s1, &s2);
        HT[s1].parent = HT[s2].parent = i;
        HT[i].lchild = s1;
        HT[i].rchild = s2;
        HT[i].weight = HT[s1].weight + HT[s2].weight;
    }
}
```
- 给每个叶子结点创建哈夫曼编码
```C
/*
*description：给每个叶子结点创建哈夫曼编码
*@param  HT：已经构建好的哈夫曼树，大小为2n-1
*@param  n：叶子结点数
*/
void HuffmanCode(HuffmanTree HT, int n) {
	//定义并分配一个二维字符数组HC，用于保存每个叶子节点的哈夫曼编码字符串；HC[1..n]用于存储 n 个编码（0号元素不用）
    char **HC = (char **)malloc((n + 1) * sizeof(char *));
    //定义一个临时字符数组cd用于构造当前节点的哈夫曼编码；最多长度为n-1因为哈夫曼编码不会比n-1更长
    char *cd = (char *)malloc(n * sizeof(char));
    //在临时存储数组末尾添加终止符'/0'，作为结束标志
    cd[n - 1] = '\0';
	//对所有叶子结点进行遍历，逐个生成哈夫曼编码
    for (int i = 1; i <= n; ++i) {
	    //我们从数组的末尾开始填入编码的每一位
        int start = n - 1;
        //c：当前结点；f当前结点的父结点
        int c = i, f = HT[i].parent;
		//我们从叶子结点向上追溯，一直到根结点，也就是父节点不存在
        while (f != 0) {
		        //如果当前节点是父节点的左孩子，编码为0，否则为1，并存入cd中对应位置
            cd[--start] = (HT[f].lchild == c) ? '0' : '1';
            //将结点上移一层，继续向上追溯
            c = f;
            f = HT[f].parent;
        }
		//为HC[i]分配一段新内存，长度为编码长度 + 1（包括 `\0`），将临时编码拷贝到HC[i]中
        HC[i] = (char *)malloc((n - start + 1) * sizeof(char));
        strcpy(HC[i], &cd[start]);
    }

    free(cd);

    // 打印编码
    printf("\n哈夫曼编码如下：\n");
    for (int i = 1; i <= n; ++i) {
        printf("权重 %d: 编码 = %s\n", HT[i].weight, HC[i]);
        free(HC[i]);
    }
    free(HC);
}
```
# 哈夫曼编码的解码
## 问题描述：
我们已知字符频度表`W((u,5),(v,6),(w,2),(x,9),(y,7))`，现在我们收到了一串哈夫曼编码：*11000110111101011000111101110010100101001101011101*，求出原码报文
## 解决思路
- 解码的关键在于确定字符与编码之间的对于关系，也就是构造哈夫曼编码
- 确定了编码后，由于前缀编码的特性，我们就能很轻松地确定原码
## 解决过程
1. 根据频度表构建哈夫曼树，确定哈夫曼编码
![[Pasted image 20250422145932.png|L|525]]
2. 根据上图，我们确定了哈夫曼编码：
	Y——00；X——01；V——10；W——110；U——111

3. 我们根据哈夫曼编码就能确定原码了，原码为：WYWUVVWYUVUYXXVVYWVUX