---
time: 2025-06-15
author: Fang
tags:
  - 归并排序
---
# 学习目标
- [ ] 掌握归并排序的基本思想与分治策略
- [ ] 理解归并排序的时间复杂度与稳定性分析
- [ ] 熟悉归并排序的实现步骤与递归过程
      
归并排序（Merge Sort）是一种基于**分治法**的排序算法，它的基本思想是：**先将序列划分为若干子序列，分别排序后再合并成一个有序序列**；归并排序是一种稳定的排序算法，适用于处理大规模数据排序
# 一、算法思想

归并排序遵循“**分而治之**”的思想，主要包括以下三个步骤：

1. **分解（Divide）**：将原始序列从中间划分为两个子序列；
2. **解决（Conquer）**：递归地对两个子序列分别进行归并排序；
3. **合并（Combine）**：将两个已排序的子序列合并为一个有序序列
    
这个过程一直递归到每个子序列长度为1，然后开始合并过程

归并排序的核心是“分”和“治”：

- **分**：将序列递归拆分为更小的子序列
- **治**：将有序的子序列合并成更大的有序序列
    
# 二、代码实现
```C
// 合并两个有序子序列
void merge(int arr[], int left, int mid, int right) {
    int n1 = mid - left + 1;  // 左子序列长度
    int n2 = right - mid;     // 右子序列长度

    // 创建临时数组
    int L[n1], R[n2];
    for (int i = 0; i < n1; i++) L[i] = arr[left + i];
    for (int j = 0; j < n2; j++) R[j] = arr[mid + 1 + j];

    // 合并两个子序列
    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j])
            arr[k++] = L[i++];
        else
            arr[k++] = R[j++];
    }

    // 复制剩余元素
    while (i < n1) arr[k++] = L[i++];
    while (j < n2) arr[k++] = R[j++];
}

// 归并排序递归函数
void mergeSort(int arr[], int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        mergeSort(arr, left, mid);        // 排序左半部分
        mergeSort(arr, mid + 1, right);   // 排序右半部分
        merge(arr, left, mid, right);     // 合并两个有序部分
    }
}

```
# 三、举例说明
排序序列：`[38, 27, 43, 3, 9, 82, 10]`

拆分过程：
```
[38, 27, 43, 3, 9, 82, 10]
→ [38, 27, 43, 3] 和 [9, 82, 10]
→ [38, 27] [43, 3] [9, 82] [10]
→ [38][27] [43] [3] [9] [82] [10]
```


合并过程：
```
[38] + [27] → [27, 38]
[43] + [3]  → [3, 43]
[9] + [82]  → [9, 82]
[27, 38] + [3, 43] → [3, 27, 38, 43]
[9, 82] + [10]     → [9, 10, 82]
最终合并 → [3, 9, 10, 27, 38, 43, 82]
```
# 四、性能分析

- **时间复杂度**：
    
    - 拆分序列的深度为$log_2n$
    - 每层合并操作需要遍历所有元素，时间为$O(n)$
    - 总体时间复杂度为$O(nlog⁡_2n)$
        
- **空间复杂度**：
    
    - 归并操作需要额外的辅助空间存储临时数组
    - 空间复杂度为$O(n)$
        
- **稳定性**：
    
    - 归并排序是稳定的排序算法，因为合并时相等元素保持原有顺序
        