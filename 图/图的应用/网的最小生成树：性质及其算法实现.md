---
time: 2025-05-29
author: Fang
---
# 学习目标
- [ ] 理解最小生成树的概念及其实际意义
- [ ] 掌握最小生成树的核心性质（MST性质）
- [ ] 掌握并能手动构造最小生成树的两大经典算法：Prim算法与Kruskal算法
- [ ] 理解两种算法的适用场景及时间复杂度差异
      
在图论中，生成树是连接图中所有顶点的无环子图；对于一个带权无向图（即网），可能存在多棵生成树，而其中边权总和最小的生成树称为**最小生成树（Minimum Spanning Tree, MST）**，也叫**最小代价树**
### 最小生成树的实际应用举例：
- 城市管道铺设设计，如何用最少的管道连接所有点
- 通信信号塔搭建，降低总成本的网络连接方案 
- 电网线路布局等工程问题
构造最小生成树是解决这类实际问题的关键第一步，下面我们来介绍最小生成树的构造
# 一、最小生成树的构造原理——MST性质
构造最小生成树的算法有很多，但大多数都使用了MST（**M**inumum **S**panning **T**ree）性质——设N = (V,E)是一个连通网，U是顶点集V的一个非空子集；若(u,v)是一条就有最小权值的边，其中u∈U,v∈V-U，则必然存在一棵包含边(u,v)的最小生成树

**MST性质解释**：
- 在生成树的构造过程中，图中n个顶点分属于两个集合：
	- 已经落在生成树上的顶点集：U
	- 尚未落在生成树上的顶点集：V-U
- 接下来，**应在所有连通顶点集U和未连通顶点集中的顶点选取权值最小的边**

下面介绍两个实现了MST性质最小生成树的构造算法——**Prim算法和Kruskal算法**

# 二、最小生成树构造算法——Prim算法
## 1.算法思想
- 设N = (V,E)是一个连通网，TE是N上最小生成树中边的集合
- 初始令$U={u_0}$，$(u_0∈V)$，TE = {} 
- 在所有u∈U，v∈V-U的边(u,v)∈E中，找一条代价最小（权值最小）的边$(u_0,v_0)$
- 将顶点$v_0$并入U，$(u_0,v_0)$并入集合TE
- 重复以上操作，直到$U=V$为止，则T=(V,TE)为N的最小生成树
## 2.举例
*如下图，有一个连通网结构*：
![[Pasted image 20250530150009.png|350]]
*构造过程*：
1. 我们从1号顶点出发，与1号顶点相关的边有：(1,2)、(1,3)、(1,4)；我们选择权值最小的边——(1,3)加入TE，并将3号顶点加入U集合
	- 此时U={1,3}、TE={(1,3)}
2. 更新U集合和其它顶点之间边关系：(1,2)、(1,4)、(3,2)、(3,4)、(3,5)、(3,6)；我们选择权值最小的边——(3,6)加入TE，并将6号顶点加入U集合
	- 此时U={1，3，6}、TE={(1,3)、(3,6)}
3. 更新U集合和其它顶点之间边关系：(1,2)、(1,4)、（3,2)、(3,4)、(3,5)、(6,4)、(6,5)；我们选择权值最小的边——(6,4)加入TE，并将4号顶点加入U集合
	- 此时U={1，3，6，4}、TE={(1,3)、(3,6)、（6,4）}
4. 更新U集合和其它顶点之间边关系：(1,2)、(1,4)、（3,2）、(3,4)、(3,5)、(6,5)；我们选择权值最小的边——(3,2)加入TE，并将2号顶点加入U集合
	- 此时U={1，3，6，4，2}、TE={(1,3)、(3,6)、（6,4）、（3,2）}
5. 更新U集合和其它顶点之间边关系：(1,2)、(1,4)、(2,5)、(3,4)、(3,5)、(6,5)；我们选择权值最小的边——(2,5)加入TE，并将5号顶点加入U集合
	- 此时U={1，3，6，4，2，5}、TE={(1,3)、(3,6)、（6,4）、（3,2）、（2,5）}
6. 此时，U=V，所有顶点都被包含，停止构造，最小生成树为T=(V,TE)
# 三、最小生成树构造算法——Kruskal算法
## 1.算法思想
- 设连通网N=(V,E)，令最小生成树初始状态为只有n个顶点而无边的非连通图$T=(V,\{\})$,每个顶点自成一个连通分量
- 在E中选取代价最小的边，若该边依附的顶点落在T中不同的连通分量上（不会形成环路），则将此边加入到TE中；否则，舍去此边，选取下一条代价最小的边
- 以此类推，直到T中所有顶点都在同一连通分量上为止
## 2.举例
*如下图，有一个连通网结构*：
![[Pasted image 20250530150009.png|350]]
*构造过程*：
1. 我们构造出非连通图T，T中包含N的所有顶点，即V={1，2，3，4，5，6}
2. 我们依次选取权值最小的边来构造最小生成树：
	1. 选取(1,3)加入TE，TE={(1,3)}
	2. 选取(4,6)加入TE，TE={(1,3)、(4,6)}
	3. 选取(2,5)加入TE，TE={(1,3)、(4,6)、（2,5）}
	4. 选取(3,6)加入TE，TE={(1,3)、(4,6)、（2,5）、（3,6）}
	5. 选择(3,4)、(1,4)，但形成回路，舍去
	6. 选取(2,3)加入TE，TE={(1,3)、(4,6)、（2,5）、（3,6）、(2,3)}
	7. 其余边依次考虑，但都会形成环路，舍去
	8. 遍历完所有边后，构造结束，生成最小生成树为T=(V,TE)
# 三、两种算法比较

| 属性    | Prim算法         | Kruskal算法        |
| ----- | -------------- | ---------------- |
| 选择对象  | 每次选择顶点         | 每次选择边            |
| 时间复杂度 | $O(n^2)$，n为顶点数 | $O(e loge)$，e为边数 |
| 适用图类型 | 稠密图（边较多）       | 稀疏图（边较少）         |
| 算法思想  | 逐步扩展顶点集合       | 按权值排序边逐步合并连通分量   |
