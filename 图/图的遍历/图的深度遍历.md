---
time: 2025-05-28
author: Fang
tags:
  - 图遍历
  - 深度优先遍历
  - 邻接矩阵
  - 邻接表
---
# 学习目标
- [ ] 
- [ ]    

- 从已给的连通图中某一项出发，**沿着一些边遍历图中所有的顶点，且使每个顶点仅被访问一次，就叫做图的遍历**，这也是图的基本运算
- 图中顶点元素之间的关系情况多样，有可能存在回路，再访问某个顶点后有可能回到之前访问过的结点，*怎么样避免重复访问呢？*
- *解决思路*：设置辅助数组`visited[i]`，用来记录每个结点的访问情况
	- 初始状态`visited[i]`为0；
	- 顶点`i`被访问后，改为1，防止被多次访问
- 图常用的遍历方式有两种：**深度优先遍历（DFS）和广度优先遍历（BFS）**

 下面我们来介绍深度优先算法
# 一、深度遍历基本思想
图的深度优先遍历是一种**类似于树的先序遍历**的图遍历算法，其核心思想是：**从某个顶点出发，尽可能“深”地搜索图中的顶点，直到无法继续，再回溯继续搜索未访问的顶点**
## 算法思路
1. 从起始顶点开始访问；
2. 访问当前顶点后，标记为“已访问”；
3. 递归访问当前顶点的**未访问邻接点**；
4. 若某路径无可访问邻点，则回溯到上一个顶点继续尝试
5. 直到所有顶点都被访问后，才结束遍历

*例*：有如下这样一个图结构，求深度遍历次序
![[Pasted image 20250529130904.png|300]]
*解*：根据算法设计，我们得到遍历顺序为：
```
1 -> 2 -> 4 -> 8 -> 5 -> 3 -> 6 -> 7
或
1 -> 2 -> 5 -> 8 -> 4 -> 3 -> 6 -> 7
或.......
```
# 二、深度遍历算法的实现
之前我们学过树的遍历操作，了解其基于递归实现的本质；
图由于具有相似的结构，同样可以**使用遍历的思想来进行图的深度遍历**；
图存储结构的实现有邻接矩阵和邻接表两种实现方式，下面我们来分别介绍
## 1.用邻接矩阵实现
我们以顶点 `0` 为起点，对该图进行**深度优先遍历（DFS）**，核心步骤如下：
1. 将当前顶点标记为已访问；
2. 访问当前顶点；
3. 遍历邻接矩阵中当前顶点对应的那一行所有顶点；
4. 若某个顶点与当前顶点有邻接关系且未被访问，则递归调用 DFS 访问该顶点
### 举例
*例*：
有如下的一个无向图和其邻接矩阵：
![[Pasted image 20250528154324.png|250]]
$$\left[\begin{array}{c c c c c}{{0}}&{{1}}&{{0}}&{{1}}&{{0}}\\ {{1}}&{{0}}&{{1}}&{{0}}&{{1}}\\ {{0}}&{{1}}&{{0}}&{{1}}&{{1}}\\ {{1}}&{{0}}&{{1}}&{{0}}&{{0}}\\ {{0}}&{{1}}&{{1}}&{{0}}&{{0}}\end{array}\right]$$
*算法流程*：
- **对顶点 1 调用 DFS**
    - 标记并访问顶点 1；
    - 遍历邻接矩阵第 1 行，发现顶点 2 为邻接点，递归调用 DFS(2)
- **对顶点 2 调用 DFS**
    - 标记并访问顶点 2； 
    - 遍历第 2 行，发现顶点 3 为未访问的邻接点，递归调用 DFS(3)  
- **对顶点 3 调用 DFS**
    - 标记并访问顶点 3；
    - 遍历第 3 行，发现顶点 4 为未访问的邻接点，递归调用 DFS(4)
- **对顶点 4 调用 DFS**
    - 标记并访问顶点 4；
    - 遍历第 4 行，没有未访问的邻接点，返回上一层
- **返回顶点 3，继续遍历第 3 行**
    - 发现顶点 5 为未访问的邻接点，递归调用 DFS(5)
- **对顶点 5 调用 DFS**
    - 标记并访问顶点 5；
    - 遍历第 5 行，没有未访问的邻接点
- 所有递归返回，DFS 过程结束

*遍历顺序*：
```
1 -> 2 -> 3 -> 4 -> 5 
```
我们能看到，由于邻接矩阵的唯一性，**使用邻接矩阵进行深度遍历的结果也是唯一的**
### 代码实现
```C
void DFS(AMGraph G,int v){
	cout<<v;                                  
	visited[v] = true;                   //从第i个顶点访问
	for(int w = 0;w < G.vexnum; w++){     //依次检查v所在的行
		if((G.arcs[v][w] != 0) && (!visited[w])){
			DFS(G,w);                    //w是v的邻接矩阵，如果w未被访问，就对其递归调用DFS
		}
	}
}
```
## 2.用邻接表实现
我们将数组中第一个头结点（顶点结点）作为起点，进行深度遍历：
1. 将当前顶点标记为已访问；
2. 访问当前顶点；
3. 遍历当前顶点的单链表中的边节点（即邻接点）；
4. 若某个邻接点未被访问，则递归调用 DFS 访问该邻接点
### 代码实现
```C
void DFS(ALGraph G, int v) {
    // 访问当前顶点，输出顶点信息
    cout << G.vertices[v].data ;
    // 标记当前顶点为已访问
    visited[v] = true;
    // 获取当前顶点的第一个邻接点
    ArcNode *p = G.vertices[v].firstarc;
    // 遍历当前顶点的所有邻接点
    while (p != NULL) {
        // 如果邻接点未被访问，则递归调用 DFS 访问它
        if (!visited[p->adjvex])
            DFS(G, p->adjvex);
        // 访问下一个邻接点
        p = p->nextarc;
    }
}
```
## 3.算法效率分析
- 用邻接矩阵来遍历，遍历图中每一个顶点都要从头扫描该顶点所在行，时间复杂度为$O(n^2)$
- 用邻接表来表遍历，虽然有2e个表结点，但只需要扫描e个结点即可完成遍历，加上访问n个头结点的时间，时间复杂度为$O(n+e)$

