---
date: 2025-04-09
author: Fang
tags:
  - 二叉树
  - 遍历算法
  - 递归实现
  - 非递归遍历
  - 层次遍历
---
在前几节，我们实现了二叉树的两种存储结构，现在我们已经可以将树的结构和内容完整地存入存储空间中；
但是，有存入就有读取，二叉树是一种特殊的结构，我们该怎么样对二叉树的元素进行读取呢，这就引出了**二叉树的遍历**
# 遍历的相关概念
## 遍历的定义
- 在树的结构内，顺着某条搜索路径巡防二叉树中的结点，使得每个结点有且仅有被访问一次，这就是**遍历**（又称**周游**）
- 为了保持搜索路径的灵活性，在这里我们借助二叉链表的指针域；在下面，我们主要**使用二叉链来实现遍历**
>访问的含义很广，可以是对结点做各种增删查改的处理，但是访问不能破坏原来的数据结构
## 遍历的目的
- 我们对二叉树进行遍历操作后，会得到树中所有结点的一个线性序列；
- 在这个线性排列的基础上，我们可以对树进行操作；
- 遍历是对树操作的前提，是**二叉树一切运算的基础和核心**
## 遍历的种类
对于任意一个二叉树，都有三个部分：根节点（`D`）、左子树（`L`）、右子树（`R`），我们想遍历整个二叉树，就需要遍历这三个部分，我们规定遍历时遵守先左后右的顺序，则有三种遍历情况：

| 遍历顺序  | 名称      | 实际操作                      |
| ----- | ------- | ------------------------- |
| `DLR` | 先（根）序遍历 | 先访问根节点，再先序遍历左子树，最后先序遍历右子树 |
| `LDR` | 中（根）序遍历 | 先中序遍历左子树，再访问根节点，最后中序遍历右子树 |
| `LRD` | 后（根）序遍历 | 先后续遍历左子树，再后序遍历右子树，最后访问根节点 |
由于二叉树本身就是递归式定义实现的，在遍历左、右子树时，我们可以**递归**地使用遍历，遍历完整棵子树
>递归：指的是**一个函数在其定义中调用自己**，直到满足某个**终止条件**为止；面对复杂问题时，把问题不断“自我拆解”，直到变成最小问题，再一层层返回答案
# 遍历序列的推导
- 我们知道，二叉树中存储的结点一般不相同，用不同的遍历顺序得出的序列也不会相同，也就是唯一的；
- 在一般情况下，我们可以根据多个不同的遍历序列来**逆向推导出树的结构**
## 推导案例
对于一个二叉树，我们已知先序和中序序列，构造出相应的二叉树
先序：`A B C D E F G H I J`
中序：`C D B F E A I H G J`
### 解决思路
#### 1.明确根节点，划分左右子树元素
根据先序序列，我们可以知道根节点为`A`；结合中序序列，我们可以得知`CDBFE`为左子树元素、`IHGJ`为右子树元素
```txt
       [  A  ]
       /      \
  [CDBFE]   [ IHGJ ]
```
#### 2.找出左右子树的根结点和左右元素
在第一步中，我们明确了左、右子树的元素；
由于先序序列中，根节点后为`B`，我们确定了左子树的根节点为`B`，其左元素为`CD`，右元素为`FE`；
同理，得出右子树的根节点为`G`，其左元素为`IH`，右元素为`J`
```txt
       [  A  ]
       /       \
  [  B  ]    [  G  ]
  /    \       /    \
[C D] [F E] [I H]   [ J ]
```
#### 3.依次递归推导左右序列
现在，我们已经明确了左、右子树的元素，接着进行排列
左子树的左元素先序排列为`CD`，中序排列为`CD`，我们就能确定`C`为`B`的左子节点，`D`为`C`的右子节点；
同理，我们也能推导出其余结点之间的关系
```txt
        [ A ]
       /      \
   [ B ]       [ G ]
   /         /     \
[ C ]     [ H ]   [ J ]
	\       /
[ D ]    [ I ]
```

## 推导方法
### 前序遍历 + 中序遍历
- 前序遍历的第一个节点是根节点
- 在中序遍历中找到该根节点，其左边是左子树，右边是右子树
- 递归构造左右子树
### 中序遍历 + 后序遍历
- 后序遍历的最后一个节点是根节点
- 在中序遍历中找到根节点，左边是左子树，右边是右子树
- 递归构建左右子树
### 前序遍历 + 后序遍历
注意，**前序遍历和后序遍历不能确定普通二叉树的结构**（除非是满二叉树）
# 递归实现遍历算法
- 我们知道，树的结构本质上是亲子结点之间递归形成的；面对这种的复杂的结构，我们使用递归思想来遍历树的结构，使得算法的实现更加简单
- 遍历算法的递归实现，是**在二叉链表的存储结构上递归调用函数实现**的，二叉链的存储结构如下：
```C
typedef int TElemType
typedef struct BiNode{
	TElemType data;
	struct BiNode *Lchild,*Rchild;
}BiNode,*BiTree;
```
## 先序遍历
- 算法描述：若二叉树为空，则不进行操作；若二叉树不为空，先访问根节点，再前序遍历左子树，最后前序遍历右子树
### 代码实现
```C
Status PreOrderTraverse(BiTree T){
	if(T == null) return OK;
	else{
		//在这里visit函数没有实际意义，我们代指对元素进行访问操作
		visit(T); 
		PreOrderTraverse(T->Lchild);
		PreOrderTraverse(T->Rchild);
	}
}  
```
## 中序遍历
- 算法描述：若二叉树为空，则不进行操作；若二叉树不为空，先中序遍历左子树，再访问根节点，最后中序遍历右子树
### 代码实现
```C
Status InOrderTraverse(BiTree T){
	if(T == null) return Ok;
	else{
		InOrderTraverse(T->Lchild);
		visit(T);
		InOrderTraverse(T->Rchild);
	}
}
```
## 后序遍历
- 算法描述：若二叉树为空，则不进行操作；若二叉树不为空，先后序遍历左子树，再后序遍历右子树，最后访问根节点
### 代码实现
```C
Status PostOrderTraverse(BiTree T){
	if(T == null) return Ok;
	else{
		PostOrderTraverse(T->Lchild);
		PostOrderTraverse(T->Rchild);
		visit(T);
	}
}
```

## 算法分析
- 在上面，我们可以看到三种算法的**访问的路径基本相同**（先左后右），唯一不同的就是**访问根节点的时机不同**
- 对于每个结点，在执行递归算法的过程中都会被''经过''**三次**；其中一次是作为根节点，遍历函数的''入口''，两次是在遍历完左右子树，返回上一层级的''出口''
- 对于某个结点：如果在第一次经过时进行访问，那就是先序遍历；在第二次经过时进行访问，那就是中序遍历；在第三次经过时进行访问，那就是后序遍历
- 时间效率：`O(n)`；空间效率：`O(n)`
# 非递归实现遍历算法
## 算法设计思路
- 我们在前面使用了递归算法来实现了遍历，虽然递归遍历简洁易懂，但是也存在一些潜在的缺点和局限性；
- 递归算法本质上是使用**函数来调用栈**来实现的，在面对大型的二叉链表时，系统消耗的资源过多、性能低下，还有可能导致**栈溢出**；另外，由于算法内**栈是隐式的**，也不利于调试和控制
- 为了解决这些问题，我们将算法内的**栈调用显示**，手动维护栈；这也就引出了**遍历算法的非递归实现**
- 在这里，我们使用**中序遍历**来作为实现案例
## 算法描述
- 初始化：  
	创建一个空栈，存放遍历过程中遇到的结点；设一个指针 `p` 指向根节点
- 开始遍历：  
	当 `p` 不为空，或栈不为空时，重复以下操作：
	 1. **沿左子树方向遍历**：
	    - 若 `p` 不为空，则将 `p` 压入栈中；
	    - 然后令 `p = p->lchild`，即继续沿左子树方向遍历，直到最左端
	2. **回退并访问节点**：
	    - 当 `p` 为空时，说明已到达某子树的最左端；
		- 此时从栈顶弹出一个结点，将其设为 `p`；
	    - 访问该结点（例如输出 `p->data`）；
	3. **转向右子树**：
	    - 访问完当前结点后，将 `p` 移动到该结点的右孩子，即 `p = p->rchild`；
	    - 然后继续下一轮循环
- 结束条件：  
	当 `p == NULL` 且栈为空时，表示整棵树的中序遍历已完成，算法结束
## 过程演示
假设有这样的一颗二叉树：
```txt
      A
     / \
    B   C
   / \
  D   E
```
栈的操作：
`A`压栈 -> `B`压栈 -> `D`压栈 -> `B`弹栈 -> `E`入栈 ->`E`弹栈 ->`A`弹栈 -> `C`压栈 -> `C`弹栈
最终中序遍历的输出结果是：`D B E A C`
## 代码实现
```C
void InOrderTraverse(BiTree T) {
    SqStack stack;
    InitStack(&stack);
    BiTree p = T;
		
    while (p || !IsEmpty(&stack)) {
        // 向左走，把路径上的每个节点压入栈
        while (p) {
            Push(&stack, p);
            p = p->Lchild;
        }
        // 左子树遍历结束，开始弹栈访问
        Pop(&stack, &p);
        printf("%c ", p->data);  // 访问当前节点
        // 转向右子树
        p = p->Rchild;
    }
    DestroyStack(&stack);
}
```
# 二叉树的层次遍历
- 我们知道，二叉树结点之间的关系不仅有亲子关系，还有兄弟关系；拥有兄弟关系或者堂兄弟关系的结点，它们在树结构中属于同一个层次；
- 我们可以利用二叉树的层次关系来实现二叉树的遍历，也就是**层次遍历**；
- 对于一棵二叉树，从根节点开始，按从上到下、从左到右的顺序来访问每一个结点，每个结点仅仅被访问一次
>从逻辑结构上来讲，之前的遍历算法是从树的深度方向来进行遍历，而层次遍历是从树的广度方向来进行遍历，这也就决定了层次遍历算法的实现与众不同
## 算法设计思路
- 层次遍历的核心思路是**从上到下、从左到右、逐层访问**；也就是说，**谁先被访问，谁的孩子结点就先被等待访问**，这与**队列**的功能十分吻合，我们使用队列来实现层次遍历
- 队列的结构定义如下：
```C
#define MAXSIZE 100
typedef struct{
	BiTree data[MAXSIZE];
	int front,rear;
}Squeue;
```
## 算法描述
- 初始化：初始化一个队列，来存放结点
- 开始遍历：
	- 将根结点入队；
	- 队列不为空时循环执行：将第一个结点`p`出队，访问它；
		- 若结点有左孩子结点，将左孩子结点入队；
		- 若结点有右孩子结点，将右孩子结点入队；
- 结束条件：队列为空时，说明树遍历完成，算法结束
## 过程演示
有如下的一棵二叉树：
```txt
      A
    /    \
   B      C
  / \    /  \
 D   E  F    G
```
队列的操作：
`A`入队 -> `A`出队 ， `B`、`C`入队 -> `B`出队 ，`D`、`E`入队 -> `C`出队，`F`、`G`入队 ->`D`、`E` 、`F`、`G`出队
最终读取的顺序为：`A B C D E F G`
## 代码实现
```C
void LevelOrder(BiTree T){
	if(T == null) return;
	BiNode *p;
	Squeue Q;
	InitQueue(&Q);
	//根节点入队
	EnQueue(&Q,T);
	//循环遍历结点，直到队列为空时结束
	while(!QueueEmpty(Q)){
		DeQueue(&Q,&p);
		visit(p);
		//左右孩子结点入队
		if(p->Lchild != null) EnQueue(&Q,p->Lchild);
		if(p->Rchild != null) EnQueue(&Q,p->Rchild);
	}
}
```
# 遍历算法的应用
## 二叉树的建立
- 我们知道，通过遍历序列（如先序+中序，中序+后序等），可以获取二叉树的结构；
- **反过来**，若我们拥有带有结构信息的遍历序列（如先序+占位符），则可以**还原并建立出完整的二叉树**
### 算法设计思路
- 单独的遍历序列并不能唯一确定一棵树结构，因此我们需要**引入额外的结构信息**；
- 就像顺序二叉树存储中会**预留空位置**一样，我们在遍历序列中加入占位符（如 `#`）来表示空结点，从而使树结构信息完整；
- 本例中使用**先序遍历序列**构建二叉树，`#` 表示对应位置的子树为空。
### 算法描述
- **初始条件**：从输入中读取一串先序遍历序列（包括 `#` 占位符），并传入指向根节点的指针 `*T`；
- **执行过程（先序遍历）**：
    1. 从输入中读取一个字符 `ch`：
        - 若 `ch == '#'`，说明当前子树为空：
            - 将 `*T` 设置为 `NULL`；
            - 返回上一层递归；
    2. 若 `ch` 为有效节点数据（如字符 `'A'`、`'B'` 等）
        - **先处理当前节点**：
            - 分配新节点空间，创建当前节点；
            - 将 `ch` 赋值给当前节点的 `data` 域；
        - **再访问左子树**：递归调用建树函数，创建当前节点的左孩子；
        - **再访问右子树**：递归调用建树函数，创建当前节点的右孩子；
        - 若子树遇到 `#`，则回退到双亲节点继续构造另一个分支；
- **结束条件**：当输入字符序列全部处理完毕，树结构建立完成，`*T` 指向整棵二叉树的根节点
### 代码实现
```C
//建立二叉树
Status CreateBiTree(BiTree *T){
	//输入序列(序列中的空结点使用#占位)
	char ch;
	scanf(" %c",&ch);
	if(ch == '#'){
		*T = null;
	}else{
		*T = (BiTNode *)malloc(sizeof(BiTNode));
		if(!T) return ERROR;
		//生成根节点
		(*T)->data = ch;
		//构造左右子树
		CreateBiTree(&(*T)->Lchild);
		CreateBiTree(&(*T)->Rchild);
	}
	return OK;
}
```
## 二叉树的复制
- 二叉树的建立是在已知二叉树序列的前提下实现的，根据序列信息创建一棵新树；
- 在已有现成树结构的情况下，我们可以将一棵二叉树的数据与结构完全复制到新的空间中，复制后的新树具有与原树完全相同的数据与结构，但在**内存中它们是不同的两棵树**
### 算法设计思路
- 我们通过递归的方式遍历原树的每个节点，并逐个创建新节点
- 复制的过程中，确保新树与原树相同的结构和数据，但每个节点在内存中的位置不同
- 我们采用**先序遍历**的方式进行树的复制，因为先序遍历可以确保我们先访问根节点，再访问左子树和右子树
### 算法描述
- 初始条件：输入一棵已存在的二叉树根节点 `T`，以及指向新树根节点的指针 `*newTree`；
- 执行过程：
    1. 若当前结点 `T == NULL`，说明已递归到空子树：
        - 将新树对应结点 `*newTree` 设置为 `NULL`；
        - 返回上一层递归；
    2. 若当前结点 `T != NULL`，则递归地执行以下操作：
        - **先处理当前节点**：
            - 为新树创建一个新节点，并分配内存；
            - 将当前节点的 `data` 赋值给新节点； 
        - **再访问左子树**：递归调用复制函数，将原树左子树复制给新树的左子树；
        - **再访问右子树**：递归调用复制函数，将原树右子树复制给新树的右子树；
        - 每完成一次子树复制后，递归回退到双亲节点，继续另一个子树的复制；
- 结束条件：原树所有结点均被访问并复制，新树构建完成，且结构与数据完全一致但内存独立。
### 代码实现
```C
// 复制二叉树
Status CopyBiTree(BiTree T, BiTree *newTree) {
    // 如果原树为空，直接返回
    if (T == NULL) {
        *newTree = NULL;
    } else {
        // 创建新节点
        *newTree = (BiTNode *)malloc(sizeof(BiTNode));
        if (!(*newTree)) return ERROR; // 内存分配失败
        // 复制当前节点的数据
        (*newTree)->data = T->data;
        // 递归复制左子树和右子树
        CopyBiTree(T->Lchild, &(*newTree)->Lchild);
        CopyBiTree(T->Rchild, &(*newTree)->Rchild);
    }
    return OK;
}
```
## 二叉树深度计算
- 二叉树的深度是指从根节点到叶子节点所经历的**最长路径的节点数**；
- 我们可以通过**递归遍历整棵树**，依次比较左右子树的深度，最终得到整棵树的最大深度
### 算法设计思路
- 从根节点开始，分别计算左子树和右子树的深度；
- 每次递归返回该子树的最大深度，即当前节点的深度应为其左右子树最大深度加一（即包含当前节点本身）；
- 我们采用**后序遍历**（即左->右->根）的方式处理更适合这种“自底向上”的计算
### 算法描述
- 初始条件：输入一棵已存在的二叉树根节点 `T`；
- 执行过程（后序遍历）：
    1. 若当前结点 `T == NULL`，说明已递归到空子树，返回深度 0；
    2. 若当前结点 `T != NULL`
	- 对左右子树进行递归，统计左右子树的深度，并返回深度较大的值
- 结束条件：根节点深度计算完成，返回整棵树的最大深度
### 代码实现
```C
// 计算二叉树的最大深度
int TreeDepth(BiTree T) {
    if (T == NULL) {
        return 0; // 空树深度为 0
    } else {
        // 1. 先递归访问左子树
        int leftDepth = TreeDepth(T->Lchild);
        // 2. 再递归访问右子树
        int rightDepth = TreeDepth(T->Rchild);
        // 3. 最后合并左右子树的结果，返回当前结点深度
        return (leftDepth > rightDepth ? leftDepth : rightDepth) + 1;
    }
}
```
## 二叉树的结点数统计
- 在遍历整棵树的过程中，我们可以统计整棵二叉树中**结点的总数**
- 利用递归的方式，从根节点出发，逐层向下统计左右子树结点数量，再加上当前节点，最终得到整棵树的结点数
### 算法设计思路
- 我们从上到下遍历树结构，但是从下向上来对结点进行计数，从左右子树**向上逐层回传结点数**；
- 每个非空树的结点总数 = 左子树结点数 + 右子树结点数 + 1（根节点本身）；
- 每个空结点会返回0，不影响统计结果；
- 递归结束后，根节点返回的是整棵树的结点总数
### 算法描述
- 初始条件：传入指向二叉树根节点的指针 `T`；
- 执行过程（后序遍历）：
    1. 若当前节点 `T == NULL`：
        - 说明该子树为空；   
        - 返回结点数为 `0`，并回退到上一层递归；   
    2. 若当前节点 `T != NULL`：
        - 对左右子树递归，返回左右子树的结点数和根节点总数 
- 结束条件：当根节点的递归结束时，即可获得整棵树的结点总数
### 代码实现
```C
// 统计二叉树中节点总数
int CountNodes(BiTree T) {
    if (T == NULL) {
        return 0; // 空树返回0
    } else {
        return CountNodes(T->Lchild) + CountNodes(T->Rchild) + 1;       // 当前树总结点数
    }
}
```
## 二叉树叶子节点统计
- 叶子节点是指左右子树均为空的结点，我们在统计叶子节点的个数时也是依据这个进行判断
### 算法设计思路
- 我们通过递归的方式，遍历二叉树的每一个节点；
- 判断当前节点是否为叶子节点（即**左右子树都为空**），若是则计数；
- 否则继续递归遍历其左右子树，直到所有节点都被访问完毕；
- 最终将所有叶子节点数加总返回。
### 算法描述 
- 初始条件：传入一棵二叉树的根节点 `T`；
- 执行过程：
    1. 若当前结点 `T == NULL`，说明是空子树，返回 0；
    2. 若当前结点左右子树均为空，说明该节点是叶子节点，返回 1； 
    3. 否则，递归统计左右子树中的叶子节点数，并将结果相加； 
- 结束条件：所有节点访问完毕后，函数返回整棵树中叶子节点的总数
### 代码实现
```C
int LeafCount(BiTree T){
	//如果是空树，返回0
	if(T == null) return 0;
	//如果是叶子节点，返回1
	if(T -> Lchild == null && T-> Rchild == null){
		return 1;
	}else{
		//递归遍历该节点的左右子树
		return LeafCount(T->Lchild) + LeafCount(T-> Rchild);
	}
}
```
# 总结
本节内容涵盖了二叉树的核心操作：**树的建立、复制、深度计算、节点总数统计以及叶子节点统计**，都是学习与应用树结构必须掌握的基本算法
- 我们统一采用了递归的实现方式，将每个结点看作一个独立的子问题，层层分解，逐步求解，使复杂结构的处理变得清晰有序；
- 这些操作虽各有侧重，但本质上都依赖于对左右子树的递归处理。无论是结构的构建还是信息的统计，关键在于理解：**每一层的处理逻辑**与**递归返回值的传递过程**；
- 掌握这些基础方法，有助于打牢后续深入学习遍历、查找、表达式处理等更复杂二叉树算法的基础