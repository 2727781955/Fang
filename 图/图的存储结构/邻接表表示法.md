---
time: 2025-05-28
author: Fang
---
# 学习目标
- [ ] 
- [ ]    

为了更高效的利用空间，方便对图的操作，我们引入了邻接表（链式表示法），下面来介绍邻接表表示法
# 一、无向图邻接表表示法
## 1.实现思路
- 我们将图中所有顶点的信息按照顺序存入一个**一维数组**中，数组中每个元素都是一个链表，每个顶点在数组中的位置由其**顶点序号**决定
- 数组中的每个元素对应一个**链表的头结点**，表示以该顶点为起点的所有边
- **头结点**除了可以存储顶点本身的信息（如顶点数据、标志位等），还包含一个指针，指向该顶点的一个邻接点
```
头结点结构示意图：
[data | firstarc]
```
- **链表中的后续节点**，称为**边结点**每个表示一个邻接点，通常包含以下两个信息：
    - 邻接顶点的**序号**
    - 指向**下一个邻接点节点**的指针
    - 和边相关的信息（权重等）
```
表结点结构示意图
[adjvex | nextarc | info]
```
## 2.举例
有如下的一个无向网
![[Pasted image 20250528160404.png|350]]
用邻接表来进行存储，则如下：
![[Pasted image 20250528161759.png|450]]
## 3.特点
- 邻接表并不唯一，每个顶点的邻接点没有特别的顺序
- 若无向图中有n个顶点、e条边，则邻接表需要n个头结点和2e个表结点，适用于存储稀疏图
- 无向图中顶点`vi`的度为第`i`个单链表中的表结点数
# 二、有向图的邻接表表示法
## 1.实现思路
- 对于有向图邻接表，每个单链表**只存储该结点的出度指向的顶点**
## 2.举例
有如下一个有向图：
![[Pasted image 20250528164133.png|300]]
我们能得到这样的一个邻接表
![[Pasted image 20250528164222.png|379]]
## 3.特点
- 顶点`vi`的出度为第`i`个单链表中的结点个数
- 顶点`vi`的入度为整个单链表中邻接点域值是`i-1`的结点个数
- 所以，要**找到一个顶点的出度简单，而找到入度繁琐**
## 4.逆邻接表
为了解决找入度难的问题，我们设计出了**逆邻接表**
对于上图的有向图结构，我们有这样的逆邻接表：
![[Pasted image 20250528164747.png|289]]
- 特点：
	- 顶点`vi`的入度为第`i`个单链表中的结点个数
	- 顶点`vi`的出度为整个单链表中邻接点域值是`i-1`的结点个数
	- **找到一个顶点的入度简单，而找到出度繁琐**
# 三、图邻接表的代码实现
## 1.存储结构的实现
### (1).头结点的定义
- 邻接表的实现，在于两个关键点——一个是**数组的结构定义和单链表结构的定义**
- 邻接表的数组是由多个单链表的头结点构成的，于是我们有如下的结构定义：
```C
typedef struct VNode{
	VerTexType data;       //存储的结点信息
	ArcNode* firstarc;     //指向第一条依附该顶点的边的指针
}VNode,AdjList[MVNmu]; 
```
- 在这里`AdjList`表示的是邻接表的类型，我们在申明一个邻接表是，可以使用`AdjList v`，相当于`VNode v[MVNum]`
### (2).边结点的定义
```C
typedef struct ArcNode{
	int adjvex;                          //该边所指向的顶点的位置
	struct ArcNode* nextarc; //指向下一条边的指针
	OtherInfo info;                 //和边有关的信息
}ArcNode;
```
### (3).图的定义
```C
typedef struct{
	AdjList vertices;    //邻接表的数组
	int vexnum,arcnum;  //图中的顶点数和边数
}ALGraph;
```
## 2.无向图邻接表的建立
### 算法思想
1. 输入总顶点数和总边数
2. 建立顶点表
	1. 依次输入顶点的信息，存入顶点表中
	2. 是每个表头结点的指针域初始化为null
3. 创建邻接表
	1. 依次输入每条边依附的两个顶点
	2. 确定两个顶点的序号`i`和`j`,建立边结点
	3. 将此边结点分别插入到`vi`和`vj`对应的两个边链表的头部
### 代码实现
```C
Status CreateUDG(ALGraph &G){
	cin>>G.vexnum>>G.arcnum;               //输入图的顶点数和边数
	for(int i = 0;i<G.vexnum;++i){
		cin>>G.certices[i].data;               //输入个头结点的值
		G.vertices[i].firstarc = null;       //将头结点的指针域置为空
	}
	for(int k = 0;k<G.arcnum;++k){
		cin>>v1>>v2;                                //驶入一条边依附的两个顶点
		int i = LocateVex(G,v1);            //寻找顶点的位置
		int j = LocateVex(G,v2);
		
		p1 = new ArcNode;                  //生成一个新的边结点p1
		p1->adjvex = j;                        //邻接点的序号为j
		p1->nextarc = G.vertices[i].firstarc;
		G.vertices[i].firstarc = p1;      //将新结点p1插入顶点vi的边表头部

		p2 = new ArcNode;                //生成一个对称新的边结点p2
		p2->adjvex = i;                      // //邻接点的序号为i
		p2->nextarc = G.vertices[j].firstarc;  
		G.vertices[j].fisrtarc = p2;    //将新结点p2插入顶点vj的边表头部
	}
	return OK;
}
```
## 3.其他图结构邻接表的实现
# 四、邻接表的优缺点
## 1.优点
- 方便找到任一顶点的所有邻接点
- 节约稀疏图的空间：需要`N`个头指针和`2E`个结点（每个结点至少两个指针域）
- 对于无向图，方便计算计算任一结点的度
## 2.缺点
- 对于有向图，只能计算出度；需要构造逆邻接表才能方便计算入度
- 不方便检查任意两个顶点之间是否有边关系
# 五、邻接矩阵和邻接表的关系
1. 联系：邻接表中每个链表对应邻接矩阵中的每一行，链表中结点个数等与矩阵中每一行非零元素的个数
2. 区别：
	1. 对于任意确定的无向图，邻接矩阵是唯一的（行列号与顶点编号一致），但邻接表并不唯一（连接次序与顶点编号无关）
	2. 邻接矩阵的空间复杂度为$O(n^2)$,而邻接表的空间复杂度为$O(n+e)$
3. 用途：**邻接矩阵多用于稠密图，而邻接表多用于稀疏图**

