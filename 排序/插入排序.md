---
time: 2025-06-10
author: Fang
tags:
  - 插入排序
  - 直接插入排序
  - 折半插入排序
  - 希尔排序
---
# 学习目标
- [ ] 
- [ ] 

插入排序（Insertion Sort）是一种简单直观的排序算法，通过构建有序序列，在未排序序列中从后向前扫描，为新元素找到对应位置并插入；它在实现上通常采用原地排序，即只需要用到O(1)的额外空间
# 一、算法思想概述
- 对于一个序列，在插入a[i]之前，序列a的前半段(a[0]~a[i-1])是已排序序列，后半段(a[i]~a[n-1])是带排序序列
- 插入a[i]使a[0]~a[i-1]有序，也就是要为a[i]找到有序位置j（0<=j<=i），将a[i]插入到a[j]的位置上
   
根据插入位置查找的方式不同，我们将插入排序分为三种：
- 顺序法定位插入位置——直接插入法
- 二分法定位插入位置——二分插入法
- 缩小增量多遍插入排序——希尔排序

下面分别介绍这几种算法
# 二、直接插入排序
直接插入排序（Straight Insertion Sort）是一种简单直观的插入排序算法，其核心思想是将待排序序列分为已排序区和未排序区，**使用顺序查找法依次将未排序区的元素插入到已排序区的合适位置**，从而使整个序列有序
## 1.算法思像
- 初始时，将序列的第一个元素视为已排序区，剩余元素为未排序区
- 从未排序区依次取出元素，按从后向前的顺序扫描已排序区，找到该元素应插入的位置
- 将比该元素大的已排序元素依次后移，为新元素腾出插入位置
- 将新元素插入到合适位置，继续处理下一个未排序元素
- 重复以上过程直到所有元素均被插入排序完成

如果遇到待插入元素与已排序区中某个元素相等，通常将新元素插入到相等元素的后面，保证排序的稳定性
## 2.代码实现
直接插入排序，省略判别数组越界的操作，我们也可以在数组头部插入哨兵元素来进行判别
```C
void insertSort(SqList *L) {
    int i, j;
    for (i = 2; i <= L->length; i++) {
        if (L->r[i].key < L->r[i - 1].key) {          
            L->r[0] = L->r[i];                         // 复制插入元素为哨兵
            for (j = i - 1; L->r[0].key < L->r[j].key; --j) {
                L->r[j + 1] = L->r[j];                 // 元素后移
            }
            L->r[j + 1] = L->r[0];                     // 插入到正确位置
        }
    }
}
```
## 3.示例
假设待排序数组：{312, 126, 272, 226, 28, 165, 123}，求排序序列
*排序过程如下：*
- 初始：已排序区{312}，未排序区{126, 272, 226, 28, 165, 123}
- 插入126：{126, 312}，未排序区{272, 226, 28, 165, 123}
- 插入272：{126, 272, 312}，未排序区{226, 28, 165, 123}
- 插入226：{126, 226, 272, 312}，未排序区{28, 165, 123}
- 插入28：{28, 126, 226, 272, 312}，未排序区{165, 123}
- 插入165：{28, 126, 165, 226, 272, 312}，未排序区{123}
- 插入123：{28, 123, 126, 165, 226, 272, 312}

最终完成排序
## 4.性能分析
直接排序实现的基本操作有两个：
1. 比较序列中两个关键字的大小
2. 移动记录

操作的次数与序列本身有关联：
- 最好的情况：关键字在记录序列中顺序有序，则比较次数为$\sum_{i=2}^nn-1$，移动次数为0
- 最坏的情况：关键字在记录序列中逆序有序，则比较次数为$\sum_{i=2}^ni{\frac{(n+2)(n-1)}{2}}$，移动次数为$\sum_{i=2}^n(i+1){\frac{(n+4)(n-1)}{2}}$

所以：
- 最好情况下，时间复杂度为$O(n)$
- 最坏情况下，时间复杂度为$O(n^2)$
- 平均情况下，时间复杂度为$O(n^2)$
- 空间复杂度为O(1)，属于原地排序算法
- 稳定性：稳定排序，保持相等元素的相对位置不变

# 二、折半插入排序
折半插入排序（Binary Insertion Sort）是对直接插入排序的一种改进，其核心优化在于利用**折半查找**（二分查找）来确定待插入元素在已排序序列中的正确位置，从而减少比较次数，提高查找效率
## 1.代码实现
```C
void BInsertSort(SqList *L) {
    int i, j, low, high, mid;
    for (i = 2; i <= L->length; ++i) { // 依次插入第2~n个元素
        L->r[0] = L->r[i]; // 当前插入元素存到“哨兵”位置

        // 折半查找插入位置
        low = 1;
        high = i - 1;
        while (low <= high) {
            mid = (low + high) / 2;
            if (L->r[0].key < L->r[mid].key)
                high = mid - 1;
            else
                low = mid + 1;
        }
        // 循环结束，high+1为插入位置

        // 移动元素
        for (j = i - 1; j >= high + 1; --j)
            L->r[j + 1] = L->r[j];

        // 插入元素
        L->r[high + 1] = L->r[0];
    }
}
```
## 2.性能分析
- 折半查找比顺序查找更高效，因此折半插入排序的平均性能优于直接插入排序。
- 折半插入排序的关键码比较次数只与待排序元素个数有关，**与初始序列的有序程度无关**；**插入第i个元素时，最多需要进行⌊log⁡2i⌋+1次比较来确定插入位置**
- 当元素数量较大时，折半插入排序的总比较次数远少于直接插入排序的最坏情况，但仍多于其最好情况
- 在序列已经基本有序或完全有序的情况下，直接插入排序的比较次数通常少于折半插入排序
- 折半插入排序的对象移动次数与直接插入排序相同，依赖于对象的初始排列，所以**移动次数并没有减少**

所以：
- 时间复杂度为$O(n^2)$
- 空间负杂度为$O(1)$
- 是一种稳定排序方法
# 希尔排序
直接插入排序的核心耗时在于每次比较后都需移动元素，尤其当待插入元素距离正确位置较远时，移动次数多，效率降低

**直接插入排序效率最高的情况：**
- 待排序序列基本有序时，元素移动和比较次数都较少，效率较高。 
- 待排序元素数量较少时，算法简单且开销小，表现良好。
    
基于此，我们引出了**希尔排序**——希尔排序通过“分组插入排序”思想，**将序列按一定间隔分组，对每组分别进行插入排序，逐步缩小间隔，使序列逐渐接近有序，最终再进行一次间隔为1的直接插入排序**
这样，希尔排序在前期大幅减少逆序对，显著降低了后期插入排序的移动次数，从而整体提升排序效率
## 1.算法思想
- 将待排序序列按一定的增量（gap）分成若干组，组内元素间隔为gap
- **对每组分别进行直接插入排序**
- 缩小增量（增量之间最好是互质的），重复上述过程，**最后一个增量必须为1**
- 当增量缩小到1时，进行一次普通插入排序，完成最终排序
## 2.代码实现
```C
void ShellInsert(SqList *L, int dk) {
    int i, j;
    for (i = dk + 1; i <= L->length; ++i) {
        if (L->r[i].key < L->r[i - dk].key) {
            L->r[0] = L->r[i];  // 哨兵暂存待插入元素
            j = i - dk;
            while (j > 0 && L->r[0].key < L->r[j].key) {
                L->r[j + dk] = L->r[j];
                j -= dk;
            }
            L->r[j + dk] = L->r[0];  // 插入哨兵元素
        }
    }
}

void ShellSort(SqList *L, int dlta[], int t) {
    int k;
    for (k = 0; k < t; ++k) {
        ShellInsert(L, dlta[k]);
    }
}
```
## 3.示例
假设待排序数组：{312, 126, 272, 226, 28, 165, 123}，求排序序列
*排序过程如下*：
我们用采用经典的增量序列：gap = 3, 1

>初始gap一般取长度的一半向下取整

**第一步：gap = 3**

将数组分成3组，分别对每组进行插入排序：
- 组1（索引0, 3, 6）：312, 226, 123  
    插入排序过程：
    - 226 < 312，交换，变成 226, 312, 123
    - 123 < 226，继续交换，最终组1排序为：123, 226, 312
- 组2（索引1, 4）：126, 28  
    插入排序过程：28 < 126，交换，组2排序为：28, 126
- 组3（索引2, 5）：272, 165  
    插入排序过程：165 < 272，交换，组3排序为：165, 272

排序后数组变为：{123, 28, 165, 226, 126, 272, 312}

**第二步：gap = 1**——对整个数组进行一次普通插入排序

插入排序过程：
- 28 < 123，交换，数组变为：{28, 123, 165, 226, 126, 272, 312}
- 165 > 123，不动
- 226 > 165，不动
- 126 < 226，插入到正确位置，数组变为：{28, 123, 126, 165, 226, 272, 312}
- 272 > 226，不动
- 312 > 272，不动

最终排序结果：{28, 123, 126, 165, 226, 272, 312}
## 4.性能分析
- 希尔排序的算法效率于增量序列（gap序列）的取值有关：
	- **Shell原始序列**（gap = n/2, n/4, ..., 1）：  
	    简单易实现，但最坏情况复杂度为 $O(n^2)$ 
	- **Hibbard序列**（gap = 1, 3, 7, 15, ...，即 $2^{k−1}$）：  
	    最坏情况复杂度约为 $O(n^{3/2})$
	- **Sedgewick序列**等其他复杂序列：  
	    可以进一步降低最坏情况复杂度，接近 $O(n^{4/3})$，甚至更优
- 合理的增量序列下，希尔排序的平均时间复杂度约为$O(n^{1.25}∼1.6n^{1.25})$
- 希尔排序是**原地排序算法**，空间复杂度为O(1)
- 希尔排序在多个不同增量的分组排序过程中，相等元素可能会被分到不同组中并发生交换，导致它们的相对位置被改变，从而破坏了稳定性，所以**希尔排序是不稳定排序**
