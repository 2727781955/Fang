---
time: 2025-05-29
author: Fang
---
# 学习目标
- [ ] 
- [ ]    

本节我们来介绍图的广度遍历
# 一、广度遍历的基本思想
图的广度优先遍历是一种**类似于树的层次遍历**的图遍历算法，其核心思想是：  **从某个起始顶点出发，首先访问其所有邻接点，然后再依次访问这些邻接点的邻接点，直到所有顶点都被访问为止**
## 算法思路
1. 从起始顶点开始访问，并标记为“已访问”
2. 依次访问该顶点的所有未被访问的邻接点，并标记
3. 再依次访问这些邻接点的所有未被访问的邻接点
4. 按照“先访问过的顶点，其邻接点优先”的顺序，逐层向外扩展
5. 直到图中所有可达的顶点都被访问为止，遍历结束

*例*：有如下这样一个图结构，求广度遍历次序
![[Pasted image 20250529130904.png|300]]
*解*：根据算法设计，我们得到遍历顺序为：
```
1 -> 2 -> 3 -> 4 -> 5 ->  6 -> 7 -> 8
或
1 -> 3 -> 6 -> 7 -> 2 -> 4-> 5 -> 8
```

# 二、广度遍历算法的实现
广度优先遍历（BFS）的核心思想是：**按层次、一圈一圈地访问图中的顶点**
**先访问的顶点，其邻接点也应该先被访问**，后访问的顶点则推迟处理——这就需要一个**先进先出**的结构来管理顶点的访问顺序，**队列**完美满足这个需求
## 1. 用邻接矩阵实现
### 算法步骤
以图的邻接矩阵为基础，从顶点 `v` 出发执行广度遍历：
1. 访问并标记顶点 `v`；
2. 将 `v` 入队；
3. 当队列非空：
    - 出队一个顶点 `u`
    - 遍历邻接矩阵中 `u` 所在行，找到所有未访问邻接点 `w`
    - 将所有满足条件的 `w` 标记并入队    
### 举例
*例*：
有如下的一个无向图和其邻接矩阵：
![[Pasted image 20250528154324.png|250]]
$$\left[\begin{array}{c c c c c}{{0}}&{{1}}&{{0}}&{{1}}&{{0}}\\ {{1}}&{{0}}&{{1}}&{{0}}&{{1}}\\ {{0}}&{{1}}&{{0}}&{{1}}&{{1}}\\ {{1}}&{{0}}&{{1}}&{{0}}&{{0}}\\ {{0}}&{{1}}&{{1}}&{{0}}&{{0}}\end{array}\right]$$
*算法流程*：

1. 访问并入队顶点 1；   
2. 出队 1，发现邻接点 2 和 4，访问并入队；
3. 出队 2，发现邻接点 3 和 5，访问并入队； 
4. 出队 4，无新邻接点； 
5. 出队 3，无新邻接点； 
6. 出队 5，无新邻接点；
    
*最终遍历顺序*：
```
1 -> 2 -> 4 -> 3 -> 5
```
### 代码实现
```C
void BFS(AMGraph G, int v) {
    cout << v;                // 访问第 v 个顶点
    visited[v] = true;
    InitQueue(Q);             // 初始化队列
    EnQueue(Q, v);            // 起始顶点入队
    while (!QueueEmpty(Q)) {
        DeQueue(Q, u);        // 出队一个顶点 u
        for (int w = 0; w < G.vexnum; w++) {
            if (G.arcs[u][w] != 0 && !visited[w]) { // 若 u 和 w 相邻且 w 未访问
                cout << w;         // 访问 w
                visited[w] = true;
                EnQueue(Q, w);     // w 入队，后续访问其邻接点
            }//if
        }//for
    }//while
}//BFS
```
## 2. 用邻接表实现
### 算法步骤
从某个起始顶点 `v` 出发，进行如下操作：
1. 访问并标记 `v`；
2. 入队；
3. 当队列非空时：
    - 出队一个顶点 `u`； 
    - 遍历 `u` 对应的邻接链表中的每一个元素；  
    - 若邻接链表元素 `w` 未访问，则访问、标记并入队
### 代码实现
```C
void BFS(AMGraph, int v){
	cout<<v;                     //访问第v个顶点
	visited[v] = true;
	InitQueue(Q);         // 初始化队列
	EnQueue(Q,v);        // 起始顶点入队
	while(!QueueEmpty(Q)){
		DeQueue(Q,u);      // 出队一个顶点 u
		for(int w  = FirstAdjVex(G,u); w >= 0;w = NextAdjVex(G,u,w)){  //访问顶点的邻接链表
			if(!visited[w]){   // 访问 w
				cout<<w;
				visited[w] = true;
				EnQueue(Q,w);   // w 入队，后续访问其邻接点
			}//if
		}//while
	}//for
}//BFS 
```

- `FirstAdjVex(G, u)`：返回图 `G` 中顶点 `u` 的第一个邻接点（若没有邻接点则返回 -1）
```C
int FirstAdjVex(ALGraph G, int u) {
    if (G.vertices[u].firstarc != NULL)
        return G.vertices[u].firstarc->adjvex;  // 返回第一个邻接点编号
    else
        return -1;
}
```
- `NextAdjVex(G, u, w)`：在顶点 `u` 的邻接点中，找到继 `w` 之后的下一个邻接点（若没有则返回 -1）
```C
int NextAdjVex(ALGraph G, int u, int w) {
    ArcNode *p = G.vertices[u].firstarc;
    while (p != NULL) {
        if (p->adjvex == w && p->nextarc != NULL)
            return p->nextarc->adjvex;  // 返回 w 的下一个邻接点编号
        p = p->nextarc;
    }
    return -1;
}
```
## 3. 算法效率分析
和深度遍历一致：
- 用邻接矩阵来遍历，遍历图中每一个顶点都要从头扫描该顶点所在行，时间复杂度为$O(n^2)$
- 用邻接表来表遍历，虽然有2e个表结点，但只需要扫描e个结点即可完成遍历，加上访问n个头结点的时间，时间复杂度为$O(n+e)$

