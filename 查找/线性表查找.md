---
time: 2025-06-07
author: Fang
tags:
  - 查找算法
  - 顺序查找
  - 折半查找
  - 分块查找
---
# 学习目标
- [ ] 
- [ ]    

基于线性表存储结构实现的查找算法主要有三种：
- 顺序查找
- 折半查找
- 分块查找

我们来分别介绍这三个算法
# 一、线性查找表的存储结构
## 存储结构定义
对于任意一个存储数据，我们都可以这样表示：
```C
typedef struct{
	KeyType key;      //关键字域
	.............               //其他域，例如名称、数据值等
}ElemType;
```
我们根据定义，就能使用一个线性表来构造一个查找表：
```C
typedef struct{
	ElemType *R;
	int length;
}SSTable;
```
# 二、顺序查找
## 1.适用范围
- 查找表为**静态查找表**（查找过程中不发生插入或删除）；
- 存储结构可为**顺序表**或**线性链表**； 
- **表中元素无序**，不适合使用二分查找等需有序结构的方法

## 2.算法实现
正向表示：
```C
int Search_Seq(SSTable ST,KeyType key){
	//从查找表最后依次向前对比，若查找到就返回位置；若未查找到就返回0
	for(int i = ST.length ; i >= 1;--i){
		if(ST.R[i].key == key){
			return i;
		}
	}
	return 0;
}
```
反向表示：
```C
int Search_Seq(SSTable ST,KeyType key){
	for(int i = ST.length;ST.R[i] != key && i > 0;--i);
	if(i > 0) return i;
	else return 0;
}
```

我们也可以将**关键字Key存入表头**（称为哨兵），从后往前逐个比较，直到查找到关键字，返回所在位置；若表中不存在关键字，就返回表头位置，也就是0；
这样做可以**省略每次都要检测是否查找完成的步骤**，加快查找速度
![[Pasted image 20250607201203.png]]
```C
int Search_Seq(SSTable ST,KeyType key){
	ST.R[0] key = key;
	for(int i = ST.length;ST.R[i].key != key;--i);
	return i;
}
```
## 3.效率分析
对于任意一个查找元素，与数值无关而与位置有关：
- 查找第i个元素，需要比较n-i+1次
- 查找失败，则需要比较n+1次

我们假设每个元素查找成功的概率时相同的，为1/n；则
$$ASL = ({1/n})\sum_{i=1}^{n}(n-i+1)$$
计算结果为$ASL=(n+1)/2$，**时间复杂度为：$O(n)$**

由于需要一个辅助空间来存储关键字，所以**空间复杂度为:**$O(1)$

### 记录的查找概率不相等时如何提高查找效率?
查找表存储记录原则--按查找概率高低存储:
1. 查找概率越高，比较次数越少
2. 查找概率越低，比较次数较多
### 记录的查找概率无法测定时如何提高查找效率?
按查找概率动态调整记录顺序:
1. 在每个记录中设一个访问频度域
2. 始终保持记录按非递增有序的次序排列
3. 每次查找后均将刚查到的记录直接移至表头

## 4.优缺点分析
- 优点：算法简单；逻辑次序无要求，且适用于不同的存储结构
- 缺点：时间效率低

# 三、折半查找
前面提到，顺序查找由于查找表中的元素是无序的，所以每次查找时都只能一个一个遍历；为了提高效率，我们给查找表中的**元素进行排序**，每次就能缩小查找区间，提高时间效率
## 1.算法思路
![[Pasted image 20250607204131.png]]
- 我们将查找表中两端点命名为$low$端和$high$端，取中间位置$mid=(low+high)/2$
- 将关键字的大小和中间位置的数值进行比较，更新中间位置：
	- 若key < mid，则 high = mid - 1;
	- 若key > mid，则 low = mid + 1;
	- key == mid，则直接找到
- 反复执行以上操作，直到low>hig时，算法失效，查找失败
## 2.算法实现
循环实现：
```C
int Search_Bin(SSTable ST,KeyType key){
	int low = 1;
	int high = ST.length;
	while(low <= high){
		mid = (low + high) / 2;
		if(ST.R[mid].key == key){
			return mid;
		}else if(key < ST.R[mid].key){
			high = mid - 1;
		}else
			low = mid + 1;
	}
	return 0;
}//Search_Bin
```
递归实现：
```C
int Search_Bin(SSTable ST, keyType key, int low, int high){
	if(low>high) return 0;//查找不到时返回0
	mid=(low+high)/2;
	if(key == ST.elem[mid].key){
		return mid;
	}
	else if(key < STelem[mid].key){
		//递归,在前半区间进行查找
		Search_Bin(SSTable ST,KeyType key,int low,int mid);
	}
	else if(key < STelem[mid].key){
		//递归,在后半区间进行查找
		Search_Bin(SSTable ST,KeyType key,int mid,int high);
	}
}
```
## 3.效率分析
对于折半查找，我们每次寻找的过程都相当于进行一次判断，我们用树表示这个判断过程——称为判断树
![[Pasted image 20250607204131.png]]
对于这样一个查找表，我们根据折半查找，可以得到这样一个判断树：
![[Pasted image 20250609153701.png|500]]
- 树中每个结点中记录着查找表中的元素位置
- 每次查找，我们都需要一次比较，**比较次数等于路径上的结点数、等于结点的层数**
- 所以我们可以得到，**比较次数小于等于树的深度，即$\lfloor log_2n\rfloor+1$**

>在这里，$\lfloor x\rfloor$是指对其向下取整的意思
### 平均查找长度的计算
设查找表长n=$2^h$-1，则h=$log_2(n+1)$（则判定树的深度为h），且表中每个记录查找的概率相等$p_i = 1/n$
则平均查找长度为：
$$\begin{align*}
ASL_{bs} &= \sum_{i=1}^{n} p_i c_i = \frac{1}{n} \sum_{i=1}^{n} c_i = \frac{1}{n} \sum_{j=1}^{h} j \cdot 2^{j-1} \\
&= \frac{n+1}{n} \log_2(n+1) - 1 \\
&\approx \log_2(n+1) - 1 \quad (n > 50)
\end{align*}
$$
在这里：j表示第j层每个结点要比较的次数，$2^{j-1}$则表示每层的结点数

## 4.优缺点分析
- 优点：效率比顺序查找高
- 缺点：只适用于有序表；且存储结构仅限于顺序存储结构，无法用于链式表

# 四、分块查询
分块查询（也称分块查找或索引顺序查找）是一种结合了顺序查找和折半查找优点的查找算法
其核心思想是**将一个大的数据表划分为若干个块（子表）**，**每个块内的数据可以无序存放，但块与块之间必须满足有序关系**
## 1.算法思路
- **分块有序**：将数据表分成若干块，块内元素无序，但块间有序；具体要求是每个块的最大关键字小于后续块中任一元素的关键字
- **索引表建立**：为每个块建立索引项，索引项包含该块的最大关键字和该块第一个元素的位置，索引表按关键字有序排列
- **查找过程**：
    1. 在索引表中通过顺序查找或折半查找确定目标关键字所在的块 
    2. 在确定的块内查找具体元素采用顺序查找找到具体元素
![[Pasted image 20250609160916.png]]
## 2.效率分析
设查找表长度为n，均匀分成b块，每块包含s个元素，则有：n=b×s
查找时先在索引表中定位块，再在块内顺序查找。
### 索引表采用顺序查找
索引表长度为 b，顺序查找的平均查找长度为：
$$L_b=\frac{b+1}{2}$$

块内顺序查找的平均查找长度为：

$$L_w=\frac{s+1}2$$

因此，分块查找的总平均查找长度为：
$$ASL=L_b+L_w=\frac{b+1}2+\frac{s+1}2$$
### 索引表采用折半查找
索引表查找平均长度约为：
$$Lb=log⁡_2(b+1)$$
块内顺序查找平均长度同上：
$$L_w=\frac{s+1}2$$

总平均查找长度为：
$$ASL=L_b+L_w=log⁡_2(b+1)+\frac{s+1}2$$
## 3.优缺点分析
- 优点：插入和删除容易，无需大量移动
- 缺点：要增加一个索引表的存储空间并对初始索引表进行排序运算
- 使用情况：如果线性表既要快速查找，又要经常变更，则可以采用分块查找

# 五、三种查找方式比较
| 特性         | 顺序查找                   | 折半查找（二分查找）        | 分块查找（索引顺序查找）                              |
| ---------- | ---------------------- | ----------------- | ----------------------------------------- |
| **查找原理**   | 从头到尾逐个元素比较，直到找到目标或遍历结束 | 在有序表中通过不断折半缩小查找区间 | 先在索引表（块最大值有序）中定位块，再块内顺序查找                 |
| **适用条件**   | 无需数据有序，适用于任意存储结构       | 要求数据顺序存储且关键字有序    | 要求索引表有序，块内数据无序，适合动态变化数据                   |
| **时间复杂度**  | 最坏O(n)，平均O(n)          | 最坏和平均O(log n)     | 索引查找O(log b)或O(b)，块内顺序查找O(s)，n=b×s        |
| **平均查找长度** | 约 (n+1)/2              | 约 log₂(n+1)       | 索引查找长度 + 块内查找长度：$log⁡_2(b+1)+\frac{s+1}2$ |
| **存储结构**   | 顺序表或链表均可               | 仅顺序存储结构           | 顺序表或链表均可，需额外索引表存储空间                       |
| **优点**     | 简单，无需排序，插入删除方便         | 查找效率高，适合静态有序数据    | 兼顾查找效率和动态数据插入删除灵活性                        |
| **缺点**     | 查找效率低，数据量大时性能差         | 要求数据有序，插入删除代价高    | 需维护索引表，索引表排序和块划分有一定开销                     |
