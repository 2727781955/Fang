---
time: 2025-06-09
author: Fang
---
# 学习目标
- [ ] 
- [ ]    

在前面，我们学习了顺序表的折半查找；有序表在插入、删除操作时，为了维护表的有序性，我们需要移动表中很多记录
为了维护折半查找的优良性能，又为了提升表的可维护性，我们改用了定态的查找表——几种**特殊树结构**，使**表结构在查找过程中动态生成**
树结构的查找表主要有以下几种：
- 二叉排序树
- 平衡二叉树
- 红黑树
- B-树
- B+树
- 键树
本节我们主要介绍前两种
# 一、二叉排序树
二叉排序树（Binary Sort Tree，BST），又称二叉查找树或二叉有序树
二叉排序树的特点是，其结构通常不是一次生成的，而是**在查找过程中，当树中不存在关键字等于给定值的结点时再进行插入**
## 1.二叉排序树的定义与性质

二叉排序树或者是一棵空树，或者是具有以下性质的二叉树:
1. 若左子树不为空，则左子树上所有节点的值均小于根节点的值
2. 若右子树不为空，则右子树上所有节点的值均大于根节点的值
3. 左右子树也分别为二叉排序树
## 2.二叉树存储结构定义
存储数据定义：
```C
typedef struct{
	KeyType key;     //关键字域
	InfoType info;  //其他数据域
}ElemType;
```
二叉树结构定义：
```C
typedef struct BSTNode{
	ElemType data;
	struct BSTNode *lchild,*rchild;
}BSTNode,*BSTree;
```
## 3.二叉排序树的中序遍历
- 中序遍历的顺序是：先访问左子树，再访问根节点，最后访问右子树（左-中-右）
- 由于左子树的所有节点值都小于根节点，右子树的所有节点值都大于根节点，递归地对左右子树进行中序遍历，**最终访问的节点值是从小到大排列的，即有序序列** 
## 4.二叉排序树的查找算法
### (1)算法思路
- 若查找的关键字等于根节点，则查找成功
- 否则：
	- 若小于根节点，查找其左子树
	- 若大于根节点，查找其右子树
- 在左右子树上递归查找操作
### (2)代码实现
```C
// 查找节点 
Node* searchNode(Node* root, int key) { 
	if (root == NULL || root->data == key)
		 return root;
	if (key < root->data) 
		return searchNode(root->left, key);
	else return 
		searchNode(root->right, key); 
}
```
### (3)效率分析
二叉排序树的**平均查找长度与树的形态密切相关**
#### 最好情况：树形均衡
- **初始序列**：{45, 24, 53, 12, 37, 93}
- **树的形态**：接近完全平衡二叉树
- **平均查找长度（ASL）**：$ASL=log⁡_2(n+1)−1$
- **树的深度**：$log⁡_2n+1$
- **查找效率**：与折半查找的判定树相同，时间复杂度为$O(log⁡_2n)$
- **特点**：节点分布均匀，查找效率高  
#### 最坏情况：树形退化为单支
- **初始序列**：{12, 24, 37, 45, 53, 93}
- **树的形态**：每个新元素都比前一个大，插入后形成单链表状的“斜树”
- **平均查找长度（ASL）**：$ASL=\frac{n+1}2$
- **树的深度**：n
- **查找效率**：与顺序查找类似，时间复杂度为 $O(n)$
- **特点**：节点极度不平衡，查找效率低
### (4)效率优化
为了使二叉排序树的平均查找长度尽量小，为了避免极端情况，我们需要**使二叉树形状尽可能地平衡**，也就是**平衡二叉树**
## 5.二叉排序树的插入

### (1)算法思路
1. **从根节点开始比较**  
    将待插入的关键字与当前节点关键字比较
2. **判断插入方向** 
    - 如果待插入关键字小于当前节点关键字，转向左子树   
    - 如果大于当前节点关键字，转向右子树 
3. **递归查找插入位置**  
    重复步骤2，直到找到一个空的子树位置（即左子树或右子树为空）
4. **插入新节点**  
    在空位置创建新节点，将其作为叶子节点插入
5. **若关键字已存在**  
    通常不插入重复关键字，直接返回

### (2)代码实现
```C
struct node* insert(struct node* root, int key) {
    if (root == NULL) {
        // 树为空，创建新节点作为根节点
        return newNode(key);
    }
    if (key < root->key) {
        // 插入左子树
        root->left = insert(root->left, key);
    } else if (key > root->key) {
        // 插入右子树
        root->right = insert(root->right, key);
    } else {
        // 关键字已存在，不插入
        return root;
    }
    return root;
}
```
## 6.二叉排序树的生成
- 从空树出发，经过一系列的查找、插入操作之后，可以生成一棵二叉排序树；一个无序序列可通过构造二叉排序树变成一个有序序列，**构造树的过程就是对无序序列进行排序的过程**
- 插入的结点均为叶子结点，故无需移动其他结点
- 对于相同的无序序列，**输入顺序不同，生成的二叉排序树的结构也不同**
![[Pasted image 20250609173217.png]]
## 7.二叉排序树的删除
- 从二又排序树中删除一个结点，不能把以该结点为根的子树删去，只能删掉该结点，并且**还应保证删除后所得的二又树仍然满足二叉排序树的性质不变**
- 由于中序遍历二叉排序树可以得到一个递增有序的序列；那么，**在二叉排序树中删去一个结点相当于去有序序列中的一个结点**
- 此外我们还要保证：
	- 将因删除结点而断开的二叉链表重新链接起来
	- 防止重新链接后树的高度增加
### (1)算法思路
1. **删除的是叶子节点**  
    直接删除该节点，释放内存，更新父节点指针为NULL，不影响树的其他结构。
2. **删除的节点只有一个子树（左子树或右子树）**  
    用该节点的唯一子树替代该节点的位置，调整父节点指针指向该子树，释放被删除节点的内存
3. **删除的节点有两个子树（左子树和右子树均不为空）**  
    需要找到该节点的“替代节点”，通常有两种选择：
    - **左子树中的值最大节点**
    - **右子树中的值最小节点**

    用替代节点的值覆盖待删除节点的值，然后递归删除替代节点（该替代节点必定是叶子节点或只有一个子树，归于前两种情况处理）

### (2)代码实现
```C
struct node* deleteNode(struct node* root, int key) {
    if (root == NULL) return root;

    if (key < root->key) {
        root->left = deleteNode(root->left, key);
    } else if (key > root->key) {
        root->right = deleteNode(root->right, key);
    } else {
        // 找到待删除节点
        if (root->left == NULL) {
            struct node* temp = root->right;
            free(root);
            return temp;
        } else if (root->right == NULL) {
            struct node* temp = root->left;
            free(root);
            return temp;
        } else {
            // 左右子树均不空，找到右子树最小节点（后继）
            struct node* temp = findMin(root->right);
            root->key = temp->key;
            root->right = deleteNode(root->right, temp->key);
        }
    }
    return root;
}

struct node* findMin(struct node* root) {
    while (root->left != NULL)
        root = root->left;
    return root;
}
```

# 二、平衡二叉树
我们之前讨论过，要是二叉排序树的平均查找长度尽可能地小，就需要使二叉排序树尽可能地平衡，也就是平衡二叉树（Balanced Binary Tree），下面我们来介绍平衡二叉树
## 1.平衡二叉树的定义与性质
- **定义**：  
    平衡二叉树是一棵空树，或者它的左右**两个子树的高度差的绝对值不超过1**，且左右两个子树本身也是平衡二叉树
- **平衡因子（Balance Factor，BF）**：  
    对于任意节点，**平衡因子定义为其左子树高度减去右子树高度**；平衡二叉树要求每个节点的平衡因子只能是 −1,0,1
- **递归性质**：  
    平衡二叉树继承了二叉搜索树的性质，即左子树所有节点值小于根节点，右子树所有节点值大于根节点
- 对于有n结点的AVL树，其高度保持在$O(log_2n)$数量级，ASL也保持在$O(log_2n)$的数量级
## 2.平衡二叉树的调整
我们要强调的是，**二叉树在失衡条件下仍然能保持其序列的正确性**，调整的操作也要在这个基础上进行
旋转是恢复平衡的主要手段，通过调整节点间的连接关系来**改变树的局部结构，降低树的高度同时保持序列**，主要有四种基本旋转方式:

- **右旋（LL旋转）** 当失衡节点是由于在其左子节点的左子树中插入新节点而导致时使用；将失衡节点的左子节点提升为新的根节点，并将原根节点变为其右子节点.
    **形象记忆**：右旋就是当前节点“往右下方推”，它的左孩子“顶上来”做根

![[Pasted image 20250609202758.png|500]]
- **左旋（RR旋转）** 与右旋相反，当失衡节点是由于在其右子节点的右子树中插入新节点而导致时使用；将失衡节点的右子节点提升为新的根节点，并将原根节点变为其左子节点.
    **形象记忆**：左旋就是把当前节点“往左下方推”，它的右孩子“顶上来”做根
![[Pasted image 20250609203517.png|500]]
- **左右旋（LR旋转）** 当失衡节点是由于在其左子节点的右子树中插入新节点而导致时使用；首先对失衡节点的左子节点进行左旋，然后对失衡节点本身进行右旋.
![[Pasted image 20250609202849.png|500]]
- **右左旋（RL旋转）** 当失衡节点是由于在其右子节点的左子树中插入新节点而导致时使用；首先对失衡节点的右子节点进行右旋，然后对失衡节点本身进行左旋
![[Pasted image 20250609203607.png|500]]
## 3.例题
*给定关键字序列：(16, 3, 7, 11, 9, 26, 18, 14, 15)，要求给出构建AVL树的步骤*

*解题过程*：
1. 插入16
	- 树为空，16为根节点。
2. 插入3
	- 3 < 16，插入为16的左孩子   
```txt
  16
  /
 3
```
3. 插入7
	- 7 < 16，进入左子树；7 > 3，插入为3的右孩子。
	- 检查平衡因子：16的左子树高度为2，右子树为0，平衡因子为2，失衡 
	- **进行左右旋（LR旋转）**：7作为根节点，16作为右子树、3作为左子树
```txt
 旋转前：
   16
  /
 3
  \
   7

旋转后：
    7
   / \
  3  16
``` 
4. 插入11
	- 11 < 7，进入左子树；11 > 3，插入为3的右孩子11>7,进入右子树，插入为16的左孩子
	- 检查平衡因子：无失衡
```txt
      7
    / \
   3  16
      /
     11
```
5. 插入9
	- 9 > 7，进入右子树；9 < 16，进入左子树；9 < 11，插入为11的左孩子
	- 检查平衡因子：16的左子树高度为2，右子树为0，平衡因子为2，失衡
	- **进行右旋（RR旋转）**：11作为新的根节点，16作为右子树，9作为左子树
```txt
旋转前：
      7
    / \
   3   16
       /
    11
   /
  9
	 
旋转后：
      7
    / \
   3  11
     /  \
    9    16   
```
6. 插入26
	- 26 > 7，进入右子树；
	- 26 > 11，进入右子树；
	- 26 > 16，插入为16的右孩子；
	- 检查平衡因子：7的左子树高度为1，右子树高度为3，平衡因子为-2，失衡；
	- **进行左旋（LL旋转）**：11作为新的根节点，7为左子树，16为右子树，9加入左子树
  ```txt
  旋转前：
      7
    /   \
   3     11
        /  \
       9    16
               \
                26

旋转后：
      11
     /  \
    7    16
   / \     \
  3   9    26
````
7. 插入18
	- 18 > 11，进入右子树；18 > 16，进入右子树；18 < 26，插入为26的左孩子；
	- 检查平衡因子：节点16左子树为空，右子树高度为2，平衡因子为-2，失衡；
	- **进行右左旋（RL旋转）**：18上升为根节点，16作为左子树、26作为右子树
```txt
旋转前：
      11
     /  \
    7    16
   / \     \
  3   9    26
          /
         18

旋转后：
      11
     /  \
    7    18
 /  \   /   \
3   9 16   26  
```
8. 插入14
	- 14 > 11，进入右子树；14 < 18，进入左子树；14 < 16，插入为16的左孩子；
	- 检查平衡因子：节点16左子树高度为1，右子树为空，平衡因子为+1，平衡；节点18左子树高度为2，右子树高度为1，平衡因子为+1，平衡；
	- 整体平衡，无需旋转
 ```txt
 插入14后：
      11
     /  \
    7    18
   / \   / \
  3   9 16 26
        /
      14
```   
9. 插入15
	- 15 > 11，进入右子树；15 < 18，进入左子树；15 < 16，进入左子树；15 > 14，插入为14的右孩子；
	- 检查平衡因子：节点14左子树为空，右子树高度为1，平衡因子为-1，平衡；节点16左子树高度为2（14为根），右子树为空，平衡因子为+2，失衡；
	- **进行左右旋（LR旋转）**：15为子树根节点,14为左子树，16为右子树
```txt
旋转前：
      11
     /  \
    7    18
   / \   / \
  3   9 16 26
        / 
      14 
		\
		15
旋转后：
      11
     /  \
    7    18
   / \   / \
  3   9 15 26
        / \
      14 16
```
### 解题思路
1. 当有多个结点失衡时，我们**优先调整最小的子树**
2. 在实际操作时，不必死板记忆操作过程，结合实际数值操作更便于理解